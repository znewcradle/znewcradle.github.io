<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="This is a website to show my blogs">
<meta property="og:type" content="website">
<meta property="og:title" content="Znewradle&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Znewradle&#39;s blog">
<meta property="og:description" content="This is a website to show my blogs">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Znewradle&#39;s blog">
<meta name="twitter:description" content="This is a website to show my blogs">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Znewradle's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Znewradle's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java/multi-threads/Java异步编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="znewcradle">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Znewradle's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java/multi-threads/Java异步编程/" itemprop="url">Java异步编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T15:37:13+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/04/21/java/multi-threads/Java异步编程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/04/21/java/multi-threads/Java异步编程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java异步编程"><a href="#Java异步编程" class="headerlink" title="Java异步编程"></a>Java异步编程</h1><p>[TOC]</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>本文将以Java异步编程为核心，一方面介绍JDK的异步编程源码的实现，突出其中的良好的设计原则和蕴含的设计模式；另一方面会结合相关案例，实践Java异步编程的思想。</p>
<p>本文首先将阐释在多线程编程中同步计算和异步计算的区别。接着，本文将介绍Java Executor框架与异步任务，该部分将结合JDK源码和案例首先说明单个异步任务的提交与执行，再进一步解释如何批量执行异步任务。然后，本文将围绕<code>FutureTask</code>结合案例说明其在异步编程中的使用；之后，本文将简单介绍在Java中如何实现计划任务。最后，给出对全文的总结和相关参考资源。</p>
<h2 id="异步任务和同步任务"><a href="#异步任务和同步任务" class="headerlink" title="异步任务和同步任务"></a>异步任务和同步任务</h2><p>Java中线程与任务是一对多的关系，一个线程可以先后执行多个任务；而每个任务按照执行方式可划分为异步任务和同步任务，二者的区别可以参考下图。从图中可得，同步任务的发起和执行在同一时间线上(a)；而异步任务的发起和执行在不同时间线上(b)。</p>
<p><img src="task.png" alt="async"></p>
<p>虽然同步任务往往是阻塞的，异步任务是非阻塞的；但是它们之间并没有必然联系。同步任务在轮询的情况下，也是非阻塞的，只是其主要动作是检查相应任务是否执行结束。同样的，异步任务某些情况下也可能是阻塞的，如通过<code>ThreadPoolExecutor.submit</code>提交的任务，本身是异步执行的；但是，如果发起线程立即调用<code>Future.get</code>会导致线程阻塞。因此，阻塞和非阻塞是任务本身的一种属性和任务的执行方式，即同步和非同步并没有必然联系。</p>
<p>同步任务，往往直观、简单、容易理解；但是它又往往意味着阻塞，降低了系统的吞吐率。异步任务通常是非阻塞的，有利于提高系统吞吐率，但是其编码复杂且需要更多资源投入。二者各有优劣，需要根据具体问题场景选用合理的方案。</p>
<h2 id="Executor与异步任务"><a href="#Executor与异步任务" class="headerlink" title="Executor与异步任务"></a><code>Executor</code>与异步任务</h2><h3 id="执行单个异步任务"><a href="#执行单个异步任务" class="headerlink" title="执行单个异步任务"></a>执行单个异步任务</h3><p>在JDK中，Runnable接口和Callable接口是对任务处理逻辑的抽象；Executor接口是对任务执行的抽象。JDK解耦任务的提交与任务的执行细节，屏蔽了不必要细节，提高内聚性，符合设计模式六大原则中的迪米特原则。</p>
<p><img src="exec.png" alt="exec"></p>
<p>如上图所示，<code>ExecutorService</code>接口继承自<code>Executor</code>接口，其默认实现类是<code>ThreadPoolExecutor</code>线程池；JDK提供的实用工具类<code>Executors</code>可以根据需求能够创建并返回相应<code>ExecutorService</code>的实例，是典型的工厂模式的应用。其中，常用的返回<code>ExecutorService</code>的工厂方法如下：</p>
 <table border="1"><br>            <thead><br>                <th>方法</th><br>                <th>适用条件及注意事项</th><br>            </thead><br>            <tbody><br>                <tr><br>                    <td>public static ExecutorService newCachedThreadPool()&lt;/&gt;<br>                    </td><td rowspan="2">适合用于执行大量耗时较短且提交比较频繁的任务。如果提交的任务执行耗时较长，那么可能导致线程池中的工作者线程无限制得增加，最后导致过多的上下文切换，拖慢整个系统。<br>                    </td><br>                </tr><br>                <tr><br>                    <td>public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory)</td><br>                </tr><br>                <tr><br>                    <td>public static ExecutorService newFixedThreadPool(int nThreads)</td><br>                    <td rowspan="2">该线程池中的工作者线程永远不会超时，因此在必要时应主动关闭该线程池</td><br>                </tr><br>                <tr><br>                    <td>public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory)</td><br>                </tr><br>                <tr><br>                    <td>public static ExecutorService newSingleThreadExecutor()</td><br>                    <td rowspan="2">适合用来实现单生产者——单消费者模式</td><br>                </tr><br>                <tr><br>                    <td>public static newSingleThreadExecutor(ThreadFactory threadFactory)</td><br>                </tr><br>            </tbody><br>        </table>

<p>一般单个异步任务的流程是，利用Executors生成<code>ExecutorService</code>线程池，再利用线程池来管理单个异步任务提交和执行，其典型案例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="comment">// 创建线程池</span></div><div class="line">    ExecutorService executor = Executors.newCachedThreadPool();</div><div class="line"></div><div class="line">    <span class="comment">// 提交异步任务，其中lambda是一个Callable</span></div><div class="line">    Future&lt;String&gt; future = executor.submit(() -&gt; &#123;</div><div class="line">        System.out.println(<span class="string">"running task"</span>);</div><div class="line">        TimeUnit.SECONDS.sleep(<span class="number">5</span>);</div><div class="line">        <span class="keyword">return</span> <span class="string">"return task"</span>;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    <span class="comment">// 在主线程上继续执行其他耗时操作</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        System.out.println(<span class="string">"Other time-consuming task in main thread"</span>);</div><div class="line">        Thread.sleep(<span class="number">1000</span>);</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</div><div class="line">        System.out.println(ex.getMessage());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 获取异步任务返回的结果</span></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        System.out.println(future.get());</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</div><div class="line">        System.out.println(ex.getMessage());</div><div class="line">    &#125; <span class="keyword">catch</span> (ExecutionException ex) &#123;</div><div class="line">        System.out.println(<span class="string">"Execution Exception"</span>);</div><div class="line">        System.out.println(ex.getMessage());</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        executor.shutdownNow();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，Future接口是Java多线程中Future模式的实现，一般用来取回Callable执行的状态，其表示一个将来会完成的任务，允许多一段时间后从其中取出执行结果。Future接口是异步计算的绝佳帮手，之后会详细分析其实现类<code>FutureTask</code>，这里给出Future接口的源码。从源码中，可以看出，Future接口非常简单，其设计本身就是用来表达一个已经提交执行的异步任务，方便对异步任务状态监控、取消终止和从中获得结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// 取消任务的执行</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</div><div class="line">    <span class="comment">// 任务完成前将其取消，返回true</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 任务正常终止、异常或取消都返回true</span></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</div><div class="line">    <span class="comment">// 等待任务执行结束</span></div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</div><div class="line">    <span class="comment">// 设定等待时限，取出执行结果</span></div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException,TimeoutException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="执行批量异步任务"><a href="#执行批量异步任务" class="headerlink" title="执行批量异步任务"></a>执行批量异步任务</h3><p><code>CompletionService</code>接口是JDK提供的用于批量执行异步任务的工具，从其实现类<code>ExecutorCompletionService</code>的如下构造器，可得其本身是Executor实例与<code>BlockingQueue</code>的结合体。其中Executor对象用来实现任务的执行，而<code>BlockingQueue</code>则用来存储已经完成的任务（Future对象）同时又能保证这种生产者——消费者模式的线程安全，其主要方法是：</p>
<ul>
<li><code>Future&lt;V&gt; take() throws InterruptedException</code>，阻塞方法，用于获取异步任务执行的结果，类似于<code>BlockingQueue#take</code></li>
<li><code>Future&lt;V&gt; poll()</code>非阻塞方法，用于获取异步任务执行结果，其重载版本可以设置timeout时限，类似于<code>BlockingQueue#poll</code></li>
<li><code>Future&lt;V&gt; submit</code>用于提交结果，支持传入Callable实例和Runnable实例</li>
</ul>
<h2 id="FutureTask的分析与使用"><a href="#FutureTask的分析与使用" class="headerlink" title="FutureTask的分析与使用"></a><code>FutureTask</code>的分析与使用</h2><p>在执行单个异步任务的小节中已经对Future接口有了简单的介绍，Future接口是对于已经提交的任务的抽象。<code>FutureTask</code>本身继承于<code>RunnableFuture</code>接口，该接口继承了Runnable接口和Future接口，即<code>RunnableFuture</code>为Future接口适配了Runnable接口，是典型的适配器模式，其类图如下：</p>
<p><img src="future.png" alt="future"></p>
<p>从类图中可以，清楚地看出<code>FutureTask</code>既因为实现Runnable接口而成为任务执行逻辑的抽象，又因为实现Future接口而成为已经提交的任务的抽象。<code>FutureTask</code>的构造函数接受Runnable或者Callable实例，并且可以将Runnable实例转换为Callable实例，以便在run()方法中以统一的方式执行任务逻辑，融合了Runnable接口和Callable接口的优点：一方面其表示的异步任务可以交给专门的工作者线程执行，也可以交由Executor实例（线程池）执行；另一方面，能够直接返回其代表的异步任务的处理结果。所以，<code>FutureTask</code>实现了Runnable接口和Callable接口的统一，即任务抽象统一，由于其本身还是Future接口的实例，所以可以用它来监控提交的任务的状态，取消任务同时异步获取执行结果。综合<code>FutureTask</code>优良的特性，它是异步编程经常会用到的利器。</p>
<p><code>FutureTask</code>还支持以回调的方式（Callback）的方式来处理任务的执行结果。当<code>FutureTask</code>所代表的任务执行结束后，<code>FutureTask.done()</code>就会被执行，它与<code>FutureTask.run()</code>方法是同一线程。<code>FutureTask.done()</code>是一个protected方法，故而子类可以通过覆盖该方法直接对结果进行处理。<code>FutureTask.done()</code>同样是通过<code>FutureTask.get()</code>来获取任务的执行结果。虽然此时任务已经执行结束get方法的调用并不会导致线程阻塞，但是任务的执行结束，包括正常终止，异常终止以及任务被取消而导致终止。因此，在done方法中，调用get方法之前需要调用<code>isCancelded</code>方法来确认任务是否被取消，以免在调用get方法时，导致抛出异常<code>CancellationException</code>。</p>
<p>下面通过一个实例，来综合运用<code>FutureTask</code>，体现其运用于异步编程上的优势。JDK提供了<code>DocumentBuilder</code>用于解析XML文档，但是它仅支持同步的方式解析XML文档。因此，必须等待XML文档解析完毕才能从XML文档中进行数据查询，然而XML文档解析可能非常耗时。如果将解析操作改为异步方式，则可以提高系统的运行效率。该实例旨在通过<code>FutureTask</code>统一XML文档解析的同步方式和异步方式，并在异步解析时支持以回调的方式处理XML的解析结果。部分源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultHandler</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Document document)</span></span>;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        e.printStackTrace();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ParsingTask</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InputStream in;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Executor executor;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> ResultHandler resultHandler;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Future&lt;Document&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        FutureTask&lt;Document&gt; ft;</div><div class="line"></div><div class="line">        <span class="comment">// 利用Callable来包装解析任务</span></div><div class="line">        <span class="keyword">final</span> Callable&lt;Document&gt; task = <span class="keyword">new</span> Callable&lt;Document&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Document <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                <span class="keyword">return</span> doParse(in);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        <span class="keyword">final</span> Executor theExecutor = executor;</div><div class="line">        <span class="comment">// 同步或异步方式</span></div><div class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isAsyncParsing = <span class="keyword">null</span> != theExecutor;</div><div class="line">        <span class="comment">// 回调方式处理解析结果</span></div><div class="line">        <span class="keyword">final</span> ResultHandler rh;</div><div class="line">        <span class="keyword">if</span> (isAsyncParsing &amp;&amp; <span class="keyword">null</span> != (rh = resultHandler)) &#123;</div><div class="line">            ft = <span class="keyword">new</span> FutureTask&lt;Document&gt;(task) &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">done</span><span class="params">()</span> </span>&#123;</div><div class="line">                    callbackResultHandler(<span class="keyword">this</span>, rh);</div><div class="line">                &#125;</div><div class="line">            &#125;;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ft = <span class="keyword">new</span> FutureTask&lt;Document&gt;(task);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (isAsyncParsing) &#123;</div><div class="line">            theExecutor.execute(ft);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            ft.run();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> ft;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">callbackResultHandler</span><span class="params">(FutureTask&lt;Document&gt; ft, ResultHandler rh)</span> </span>&#123;</div><div class="line">        <span class="comment">// 获取任务处理结果前判断任务是否被取消</span></div><div class="line">        <span class="keyword">if</span> (ft.isCancelled()) &#123;</div><div class="line">            Debug.info(<span class="string">"parsing cancelled.%s"</span>, ParsingTask.<span class="keyword">this</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Document doc = ft.get();</div><div class="line">            rh.onSuccess(doc);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;</div><div class="line">            Debug.info(<span class="string">"retrieving result cancelled.%s"</span>, 	ParsingTask.<span class="keyword">this</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">            rh.onError(e.getCause());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> Document <span class="title">doParse</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        Document document = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();</div><div class="line">            document = db.parse(in);</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            Tools.silentClose(in);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> document;</div><div class="line">    &#125;</div><div class="line">	<span class="comment">// 完整源码见附件 ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从以上源码可知，利用Callable来包装原本同步的解析方式，可以用来创建<code>FutureTask</code>。如果提供了<code>executor</code>则会用异步的方式来执行解析任务；反之，直接调用<code>FutureTask#run</code>来以同步方式运行解析；完美地统一了异步方式和同步方式。此外，在创建<code>FutureTask</code>时，通过覆盖done方法可以支持以回调的方式来处理解析结果。最后，回调<code>callbackResultHandler</code>的处理中，除了通过<code>ResultHandler</code>接口来剥离结果处理的逻辑，在方法开头利用<code>FutureTask#isCancelled</code>方法来判断任务是否被取消，以免之后的get调用抛出<code>CancellationException</code>。</p>
<h2 id="计划任务"><a href="#计划任务" class="headerlink" title="计划任务"></a>计划任务</h2><p>计划任务分为两类，延迟性提交任务和周期性提交任务；JDK提供了<code>ExecutorService</code>接口的子接口<code>ScheduledExecutorService</code>接口，其中定义了一组方法用于实现这两类计划任务。</p>
<ul>
<li>延迟性提交任务：由<code>TimeUnit</code>指定时间单位，long型变量指定时长，以指明延迟的期限并在延迟到期后提交任务</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable, <span class="keyword">long</span> delay, TimeUnit unit)</span></span>;</div><div class="line">ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="keyword">long</span> delay, TimeUnit unit)</div></pre></td></tr></table></figure>
<ul>
<li>周期性提交任务：顾名思义，指有一定时间间隔且周期提交的任务；两个API共同点在于都可以指定初始时延，时间单位，并且都只支持Runnable实例；然而两个API间隔周期计算方式不同<ul>
<li>前者：间隔周期Interval由period指定，但是如果任务执行时间Execution Time超过了period，则以任务执行时间为间隔，故有，Interval &gt;= period</li>
<li>后者：delay指定上次任务执行结束后到下次任务执行前的时延，故有，Interval = Execution Time + delay</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, </div><div class="line">        <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period, TimeUnit unit);</div><div class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</div><div class="line">        <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> delay, TimeUnit unit);</div></pre></td></tr></table></figure>
<p>由上面对于<code>ScheduledExecutorService</code>接口的API介绍可得，延迟性任务最多只会被执行一次，可以利用schedule方法的返回值<code>ScheduledFuture</code>实例来获取任务执行的结果、执行过程中抛出的异常并且可以取消任务的执行。然而，周期性任务只能接受Runnable实例，无法获取计划任务的一次或多次的执行结果，不过通过返回的<code>ScheduledFuture</code>实例可以取消相应的任务。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文围绕Java异步编程主题，主要介绍了JDK源码对于异步编程的支持，以及其中良好的设计原则与设计模式应用范例，并结合相关主题给出了有针对性的案例。文章从异步编程的基础概念入手，介绍了同步任务和异步任务的概念，并将其与阻塞和非阻塞进行了概念区分。之后，本文一方面结合案例和源码说明了单个异步任务提交和执行流程以及Executors中蕴含的工厂模式；另一方面，依据源码解释了批量执行异步任务的方法和原理。而后，本文围绕<code>FutureTask</code>，分析了其源码和其中的适配器模式，探讨了其用于异步编程的可行性，最后给出了XML文档异步解析的实际案例。最后，本文简单介绍了JDK提供的对于计划任务的支持，对于<code>ScheduledExecutorService</code>接口的API进行了详细说明。</p>
<p>本文对于Java异步编程的介绍侧重于JDK底层对于异步编程的支持，许多的Java工具库对于JDK代码进行了扩展优化，提供了更易用的API，其中典型代表Google Guava库值得进行深入研究。</p>
<h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul>
<li>JDK源码</li>
<li>《Java多线程编程实战指南-核心篇》</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java/multi-threads/Java线程管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="znewcradle">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Znewradle's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java/multi-threads/Java线程管理/" itemprop="url">Java线程管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T15:36:04+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/04/21/java/multi-threads/Java线程管理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/04/21/java/multi-threads/Java线程管理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h2><ol>
<li><p>线程和线程组类似文件和文件夹，有父线程组和子线程组；JVM在创建main线程时也会为其指定线程组。所以，Java中任何一个线程都有一个线程组与之关联，可以通过调用来获取线程组<code>Thread.getThreadGroup()</code></p>
</li>
<li><p>利用<code>void uncaughtException(Thread t, Throwable e)</code>实现线程的监控；</p>
<ul>
<li>启动thread前调用<code>thread.setUncaughtExceptionHandler(eh)</code>为thread关联一个<code>UncaughtExceptionHandler</code>；</li>
<li>当thread抛出未被捕获的异常后<code>thread.run()</code>返回，接着thread会在终止前调用<code>eh.uncaughtException</code>方法（<code>UncaughtExceptionHandler.uncaughtException</code>调用结束前，线程还是存活的）</li>
<li>线程没有<code>setUncaughtExceptionHandler</code>则会调用所属线程组的<code>uncaughtException</code>方法，线程组会调用其父线程组的<code>uncaughtException</code>方法并传递（t, e）。如果线程组没有父线程组，就会调用默认的<code>UncaughtExceptionHandler</code>的<code>uncaughtException</code>方法来处理线程的异常终止</li>
</ul>
</li>
<li><p>线程工厂</p>
<ul>
<li>JDK支持线程工厂接口<code>ThreadFactory</code>其内方法<code>public Thread newThread(Runnable r)</code></li>
<li>利用<code>newThread</code>可以创建线程，其参数Runnable r代表需要执行的任务；在<code>ThreadFactory.newThread()</code>中封装线程创建逻辑，可以统一处理线程的创建、配置</li>
</ul>
</li>
<li><p>线程的高效利用：线程池</p>
<ul>
<li>线程的开销：线程的创建与启动开销；线程的销毁；线程的调度开销；能够创建的线程数受限于新系统所拥有的处理器数目</li>
<li>线程池可被看做生产者——消费者模式，JDK中<code>ThreadPoolExecutor</code>类即线程池，可以通过调用<code>ThreadPoolExecutor.submit</code>方法向其提交任务，返回Future对象。其中，线程池服务内部维护的线程相当于消费者线程，线程池的客户端相当于生产者线程</li>
<li>线程池大小：当前线程池大小，核心线程池大小 &lt;= 最大线程池大小</li>
<li><code>ThreadPoolExecutor</code>的构造器中最复杂</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize,</span></span></div><div class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> keepAliveTime, TimeUnit unit,</span></span></div><div class="line"><span class="function"><span class="params">                         BlockingQueue&lt;Runnable&gt; workQueue,</span></span></div><div class="line"><span class="function"><span class="params">                         ThreadFactory threadFactory,</span></span></div><div class="line"><span class="function"><span class="params">                         RejectedExecutionHandler handler)</span></span></div><div class="line"><span class="function"><span class="comment">// workQueue是工作队列的阻塞队列，生产者——消费者模式的传输通道</span></span></div><div class="line"><span class="function"><span class="comment">// corePoolSize用于指定线程池核心大小</span></span></div><div class="line"><span class="function"><span class="comment">// maximumPoolSize 用于指定最大线程池大小</span></span></div><div class="line"><span class="function"><span class="comment">// keepAliveTime和unit结合用于指定线程池中空闲线程的最大存活时间</span></span></div><div class="line"><span class="function"><span class="comment">// threadFactory指定用于创建工作者线程的线程工厂</span></span></div><div class="line"><span class="function"><span class="comment">// handler: 当工作队列满时，线程池会继续调用threadFactory来创建新工作者线程，</span></span></div><div class="line"><span class="function">    <span class="comment">// 直到线程池满。线程池满则会调用RejectedExecutionHandler来拒绝提交任务</span></span></div><div class="line"><span class="function">    <span class="comment">// void rejectedExecution(Runnable r, ThreadPoolExecutor executor)</span></span></div><div class="line"><span class="function">    <span class="comment">// 通过调用setRejectedExecutionHandler(...)来设置rejecthandler</span></span></div><div class="line"><span class="function">    <span class="comment">// 默认使用ThreadPoolExecutor.AbortPolicy，还有其他选项</span></span></div></pre></td></tr></table></figure>
<ul>
<li><code>ThreadPoolExectuor.shutdown()/shutdownNow()</code>可用来关闭线程池，<ul>
<li>使用shutdown()已经提交的任务会继续执行，而被新提交的任务会像线程池饱和时一样被拒绝（所以该方法返回时，线程池可能尚未关闭）</li>
<li>使用shutdownNow()则正在执行的任务也会被停止，提交的任务不会执行，新任务被拒绝，内部调用线程的interrupt方法来停止正在执行的任务（因此某些无法响应中断的任务可能永远不会停止）</li>
</ul>
</li>
<li>任务的处理结果、异常处理与取消<ul>
<li>获得处理结果：<code>public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code>，Callable接口是增强版的Runnable接口，唯一方法<code>V call() throws Exception</code>，通过<code>Execturos.callable(Runable task, T result)</code>能够将Runnable接口转换为Callable接口。Future#get方法可以获取任务的处理结果。如果任务尚未执行完毕，那么Future#get会使当前线程暂停，是个阻塞方法，能够抛出<code>InterruptedException</code>，可以响应中断，等待会导致上下文切换。因此应该尽早提交任务，仅在需要时才调用<code>get</code>方法</li>
<li><code>Future.isDone()</code>可以检测响应的任务是否执行完毕，如果完毕或者任务被取消，或抛出异常，都会返回true；用<code>V get(long timeout, TimeUnit unit) throws XXEx</code>可以指定等待时间，到期，会抛出TimeoutException；捕获之后，执行<code>Future.cancel</code>来取消任务的执行</li>
<li>利用以下方法可以进行线程池监控：<code>getPoolSize(), getQueue(), getLargestPoolSize(), getActiveCount(), getTaskCount(), getCompletedTaskCount()</code></li>
<li>同一线程池只能用来执行相互独立的任务，彼此有依赖关系的任务需提交给不同的线程执行以避免死锁</li>
<li>通过ThreadPoolExecutor.submit提交给线程池的任务，其执行过程中抛出的未捕获异常并不会导致与该线程池中的工作者线程关联的<code>UncaughtExceptionhandler</code>的<code>uncaughtException</code>方法被调用；<code>execute</code><strong>反之</strong></li>
</ul>
</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java/multi-threads/Java保障线程安全的设计技术/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="znewcradle">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Znewradle's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java/multi-threads/Java保障线程安全的设计技术/" itemprop="url">Java保障线程安全的设计技术</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T15:34:47+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/04/21/java/multi-threads/Java保障线程安全的设计技术/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/04/21/java/multi-threads/Java保障线程安全的设计技术/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="保障线程安全的设计技术"><a href="#保障线程安全的设计技术" class="headerlink" title="保障线程安全的设计技术"></a>保障线程安全的设计技术</h2><ol>
<li><p>Java运行时存储空间</p>
<ul>
<li>Java Runtime空间可分为：<ul>
<li>堆heap：JVM动态分配可扩容，存储对象，多线程共享，垃圾回收器</li>
<li>栈stack：为线程准备的固定大小的内存空间，每个线程都有其栈空间，不共享；引用型变量，栈帧中存储的是响应对象的内存地址而不是对象本身（固有线程安全）</li>
<li>非堆(Non-heap)空间：用于存储常量以及类的元数据等，JVM启动时分配可动态扩容；在多个线程之间共享存储空间</li>
</ul>
</li>
</ul>
</li>
<li><p>无状态对象</p>
<ul>
<li>对象所包含的数据即为对象的状态（实例变量、静态变量，引用其他对象的实例变量或者静态变量等），故 实例变量和静态变量 被称为 状态变量</li>
<li>如果一个类的同一个实例被多个线程共享并不会使这些线程存在共享状态，则为无状态对象；反之为有状态对象<ul>
<li>无状态对象不包含任何实例变量，只能包含只读的静态变量（常量）；但是这只是必要条件，特殊情况下，不包含任何实例变量或者静态变量的类仍旧有可能线程不安全</li>
<li>有状态对象可分为：状态可变对象 and 状态不可变对象（状态变量的值是否会变化）</li>
</ul>
</li>
<li>无状态对象具有天生的线程安全性，无须同步机制<ul>
<li>调用该对象的任何方法无须加锁</li>
<li>无状态对象自身的方法实现也无须用锁</li>
</ul>
</li>
<li>实践：正确编写Servlet类<ul>
<li>服务器为每一个servlet类最多只生成一个实例，用于处理接收的多个请求，即会被多个线程共享；并且服务器调用Servlet.service方法没有加锁，因此Servlet实例需要称为无状态对象，有利于提供服务器的并发行。</li>
<li>Servlet类一般不包含实例变量或者静态变量；否则就需要考虑锁</li>
</ul>
</li>
</ul>
</li>
<li><p>不可变对象</p>
<ul>
<li>指一经创建其状态就保持不变的对象，也具有固有的线程安全性，严格意义上需要满足的条件：<ul>
<li>类本身使用final修饰：防止通过创建子类来改变其定义的行为</li>
<li>所有字段都用final修饰：值不变且保证必定完成初始化</li>
<li>对象在初始化过程中没有逸出</li>
<li>任何字段，若其引用了其他状态可变的对象，则这些字段必须是private修饰；若要return这些字段，应进行Defensive Copy</li>
</ul>
</li>
<li>不可变对象：当其抽象的状态不断变化时，会创建多个不可变对象，加重GC负担；可以通过共享新老对象的内存来减少内存占用，比如浅复制老对象</li>
<li>应用场景<ul>
<li>被建模对象的状态变化不频繁</li>
<li>对一组相关的数据进行写操作，需要保证原子性</li>
<li>使不可变对象作为安全可靠的Map键</li>
</ul>
</li>
</ul>
</li>
<li><p><code>ThreadLocal</code>：线程特有对象</p>
<ul>
<li>只能被一个线程访问的对象就被称为线程持有对象，相应的线程就被称为该线程特有对象的持有线程</li>
<li>线程持有对象具有固有的线程安全性，ThreadLocal类是线程特有对象的代理，即通过该对象可以创建并访问各自的线程特有对象。<strong>多个线程使用同一个ThreadLocal<t>实例所访问到的对象是类型T的不同实例，即每个线程持有特定对象</t></strong></li>
<li><code>ThreadLocal</code>实例通常被作为类的静态字段使用</li>
<li>可能的问题<ul>
<li>退化与数据错乱：线程和任务之间是一对多，线程特有对象在多任务之间共享；如果特有对象有状态且会随着任务而改变，会导致数据错乱</li>
<li>内存泄漏和伪内存泄漏：对象永远无法被垃圾回收导致其占用JVM的内存而无法释放；持续的内存泄漏会导致JVM可用内存减少，并最终导致内存溢出</li>
<li>应用场景：<ul>
<li>需要使用非线程安全对象，但又不希望引入锁，想避免锁开销</li>
<li>隐式参数传递和特定线程的单例模式</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>装饰器模式</p>
<ul>
<li>为非线程安全对象创建一个相应的线程安全的外包装对象，客户端访问外包装对象来实现线程安全访问（二者具有相同接口）；典型的：<code>Collections.synchronizedXXX</code>（同步集合）</li>
<li>分离关注点——功能和线程安全</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncCollectionSafeTraversal</span> </span>&#123;</div><div class="line">    <span class="keyword">final</span> List&lt;String&gt; syncList = Collections.synchronizedList(</div><div class="line">    	<span class="keyword">new</span> ArrayList&lt;String&gt;()</div><div class="line">    );</div><div class="line">    <span class="comment">// ...</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dump</span><span class="params">()</span> </span>&#123;</div><div class="line">        Iterator&lt;String&gt; iterator = syncList.iterator();</div><div class="line">        <span class="keyword">synchronized</span>(syncList) &#123;</div><div class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</div><div class="line">                System.out.println(iterator.next());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>并发集合</p>
<ul>
<li>concurrent包中引入了线程安全的集合对象，称为并发集合（同步集合的替代品）</li>
</ul>
<p><img src="C:/Users/12874/OneDrive/MDpictures/notes/concurrentCollection.png" alt="concurrent collection"></p>
<ul>
<li>并发集合无须加锁就可线程安全遍历，对其更新则是由不同线程执行；其内部借助CAS操作或者细粒度的锁</li>
<li>实现线程安全遍历操作的两种方式<ul>
<li>快照：无法再遍历过程中反映其他线程对被遍历集合所作的更新</li>
<li>准实时：可能反映其他线程对被遍历集合所作的更新</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="线程的活性故障"><a href="#线程的活性故障" class="headerlink" title="线程的活性故障"></a>线程的活性故障</h2><ol>
<li>死锁<ul>
<li>两个或者更多的线程相互等待对方而被永远暂停，则称线程产生死锁</li>
<li>哲学家就餐问题</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java/multi-threads/Java线程间协作/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="znewcradle">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Znewradle's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java/multi-threads/Java线程间协作/" itemprop="url">Java线程间协作</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T15:32:47+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/04/21/java/multi-threads/Java线程间协作/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/04/21/java/multi-threads/Java线程间协作/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程间协作"><a href="#线程间协作" class="headerlink" title="线程间协作"></a>线程间协作</h2><h3 id="等待与通知：-wait-notify"><a href="#等待与通知：-wait-notify" class="headerlink" title="等待与通知： wait/notify"></a>等待与通知： wait/notify</h3><ol>
<li><p>概念：</p>
<ul>
<li>等待：线程因其执行目标动作所需的保护条件为满足而被暂停的过程</li>
<li><p>通知：线程更新系统状态，使得其他线程所需的保护条件得以满足的时候唤醒被暂停的线程</p>
</li>
<li><p>Java对等待和通知的实现：<code>Object.wait()/Obejct.wait(long)等待方法——对应等待线程; Object.notify()/Object.notifyAll()通知方法——对应通知线程</code>，代码模板如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 受保护方法三要素：保护条件、暂停当前线程和目标动作</span></div><div class="line"><span class="keyword">synchronized</span>(someObject) &#123;</div><div class="line">    <span class="comment">// 只有持有一个对象的内部锁时，才能调用该对象的wait方法；故必须放在引导区</span></div><div class="line">    <span class="keyword">while</span> (保护条件不成立) &#123;</div><div class="line">        someObject.wait();</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 保护条件已经满足</span></div><div class="line">    doAction();    <span class="comment">// 执行目标动作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>一个对象可能存在多个等待线程，可以通过其他线程执行<code>someObject.notify()</code>来唤醒，<code>someObject.wait()</code>会以原子操作的方式使其当前线程暂停并使该线程释放其持有的someObject对应的内部锁。</p>
<p>被唤醒的线程在其再次持有someObject对应的内部锁的情况继续执行someObject.wait()中剩余的指令，直到wait方法返回。<strong>等待线程只在保护条件不成立的情况下才执行Object.wait()进行等待，在执行Object.wait()前需要判断条件是否成立。</strong></p>
<p><strong>等待线程在其被唤醒、继续运行到其再次持有相应对象的内部锁的这段时间内，由于其他线程可能抢先获得相应的内部锁并更新了相关共享变量而导致该线程所需的保护条件又再次不成立</strong>，所以<strong>Object.wait()调用返回之后需要再次判断此时保护条件是否成立——放到循环语句中</strong>，保证目标动作只在保护条件成立的情况下才能执行！</p>
</li>
<li><p>等待线程对保护条件的判断以及目标动作的执行必须是原子操作，否则可能产生竞态；所以目标动作的执行必须和保护条件的判断以及Object.wait()的调用放在同一个对象所引导的临界区中</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 更新共享变量、唤醒其他线程</span></div><div class="line"><span class="comment">// 只有持有对象的内部锁时才能执行该对象的notify方法，因而也需放到临界区中</span></div><div class="line"><span class="comment">// Object.notify()的执行线程持有的相应对象的内部锁只有在Object.notify()调用</span></div><div class="line"><span class="comment">// 所在的临界区代码执行结束后才会被释放，方法本身并不会释放内部锁</span></div><div class="line"><span class="comment">// 所以尽可能将Object.notify放在靠近临界区结束的位置</span></div><div class="line"><span class="keyword">synchronized</span>(someObject) &#123;</div><div class="line">    <span class="comment">// 更新等待线程的保护条件涉及的共享变量</span></div><div class="line">    updateSharedState();</div><div class="line">    someObject.notify(); <span class="comment">// 唤醒其他线程</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>调用<code>Object.notify()</code>所唤醒的线程仅是相应对象上的任意等待线程；借助<code>Object.notifyAll()</code>可以唤醒所有等待线程</li>
</ul>
</li>
<li><p>wait/notify的开销及问题</p>
<ul>
<li>过早唤醒：被唤醒但是保护条件没有成立，仍需继续等待</li>
<li>信号丢失：Object.notify可能导致信号丢失</li>
<li>欺骗性唤醒：等待线程在没有任何其他线程执行Object.notify(All)的情况下被唤醒</li>
<li>上下文切换：锁的申请和释放可能会导致上下文切换</li>
<li>建议：在保证程序正确性的前提下，使用Object.notify代替Object.notifyAll，避免过早唤醒；通知线程在执行完Object.notify/Object.notifyAll之后尽快释放相应的内部锁</li>
<li>保守的做法用Object.notifyAll以保障正确性</li>
<li>join方法是同步方法，在目标线程未结束时会调用wait方法来暂停目前线程，直到目标线程终止</li>
</ul>
</li>
<li><p>Java条件变量</p>
<ul>
<li>JDK1.5引入的新标准类库<code>java.util.concurrent.locks.Condition</code>接口</li>
<li>Condition接口提供await\signal\signalAll分别相当于方法Object.wait\Object.notify\Object.notifyAll；它们同样要求执行线程持有创建该Condition实例的显式锁</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConditionUsage</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition condition = lock.newCondition();</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aGuaredMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">while</span> (保护条件不成立) &#123;</div><div class="line">                condition.await();</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 执行目标动作</span></div><div class="line">            doAction();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAction</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">anNotificationMethod</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">    	lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="comment">// 更新共享变量</span></div><div class="line">            changeState();</div><div class="line">            condition.signal();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">changeState</span><span class="params">()</span> </span>&#123; <span class="comment">//... &#125;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>Condition接口对解决过早唤醒提供了支持，但是需要通过应用代码来维护保护条件与条件变量之间的对应关系——用不同的保护条件的等待线程需要调用不同的条件变量的await方法来实现其等待并使通知线程在更新了相关共享变量之后，仅调用与这些共享变量有关的保护条件所对应的条件比那辆的signal/signalAll方法来实现通知</li>
<li><code>Condition.awaitUntil(Date deadline)</code>可以用实现带超时时间限制的等待，返回值可区分是由于等待超时返回还是由于其他线程执行了相应条件变量的signal/signalAll方法而返回。如果等待未超时，返回true可以选择继续等待：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">lock.lock();</div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">while</span> (! ready) &#123;</div><div class="line">        Debug.error(<span class="string">""</span>);</div><div class="line">        <span class="keyword">if</span> (! continueToWait) &#123;</div><div class="line">           Debug.error(<span class="string">"Wait timed out, unable to execution target"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        continueToWait = condition.awaitUntil(deadline);</div><div class="line">    &#125;</div><div class="line">    doAction();</div><div class="line">&#125; <span class="keyword">finally</span> &#123;</div><div class="line">    lock.unlock();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>倒计时协调器：CountDownLatch</p>
</li>
<li><p>栅栏（CyclicBarrier）</p>
<ul>
<li><code>java.util.concurrent.CyclicBarrier</code>：线程都到达代码中某个点时，线程才能继续执行</li>
<li>使用CyclicBarrier实现等待的线程被称为参与方，除最后一个线程外的恩赫参与方执行CyclicBarrier.await()都会导致该线程被暂停，但是最后一个线程执行CyclicBarrier.await()会使得所有参与方被唤醒，且自身不会被暂停</li>
<li>CyclicBarrier可以重复使用</li>
<li>典型的应用场景<ul>
<li>迭代算法并发化</li>
<li>在测试代码中模拟高并发</li>
</ul>
</li>
</ul>
</li>
<li><p>生产者——消费者模式</p>
<ul>
<li>生产者、消费者之间可以通过线程安全的队列<code>BlockingQueue</code>接口的实现类<code>ArrayBlockingQueue</code>来传递数据。它们是线程安全的队列——阻塞队列，分为有界队列和无界队列<ul>
<li>ArrayBlockingQueue使用同一个显式锁，从而可能导致锁的高争用，进而导致较多的上下文切换</li>
<li>LInkedBlockingQueue有两个显式锁，降低了锁争用；但是基于链表的缺点是可能增加垃圾回收的负担</li>
<li>SynchronousQueue可被看作特殊有界队列，适合于消费者处理能力与生产者能力相差不大时使用</li>
</ul>
</li>
</ul>
</li>
<li><p>流量控制与信号量</p>
<ul>
<li><code>java.util.concurrent.Semaphore</code>用来实现流量控制，信号量Semaphore相当于虚拟资源配额管理器，<code>Semaphore.acquire()/release()</code>用于申请配额和返回配额；<code>Semaphore.acquire</code>如果因配额不足会暂停执行线程；<code>Semaphore.release</code>会使当前可用配额增加1，并唤醒相应的Semaphore实例的等待队列中任意一个等待线程</li>
<li><code>Semaphore.acquire()/release()</code>的配对是需要应用代码来保证的，release应该放在finally语句中</li>
<li>可以用来实现互斥锁；也可以设置使用公平策略或者非公平性调度策略</li>
<li>生产者——消费者模型：<code>PipedOutputStream-PipedInputStream</code>可以实现线程间的直接输出和输入，不必借助其他数据交换中介。适合在两个线程间使用，即单生产者——单消费者情形；不宜在单线程中使用，因为可能导致无限制的等待</li>
<li>生产者通过关闭PipedOutputStream来知会消费者，避免无限制等待新数据</li>
</ul>
</li>
<li><p>双缓冲：消费者线程消费一个已填充的缓冲区时，另一个缓冲区可以由生产者线程进行填充，实现数据生成和消费的并发，jdk1.5引入的标准库：<code>Exchanger</code>实现了双缓冲，相当于一个只有两个参与方的CyclicBarrier，<code>Exchanger.exchange(V)</code>相当于<code>CyclicBarrier.await()</code></p>
<ul>
<li>Exchanger从逻辑上可以被看做一种SynchronousQueue，其内部不维护用于存储产品的存储空间</li>
<li>消费者和生产者都调用exchange函数来指定一个空的或已经使用过的缓冲区以及指定一个已经填充完毕的缓冲区：<code>public V exchange(V x) throws InterruptedException</code></li>
<li>线程和任务之间是一对多的关系，即一个线程可以先后执行多个任务</li>
</ul>
</li>
<li><p>线程中断机制</p>
<ul>
<li>Java线程中断，通过调用线程的<code>interrupt()</code>方法发起请求中断的指示，线程维护<strong>中断标记</strong>（boolean），此时置为true，表示收到中断。线程通过<code>Thread.currentThread.isInterrupted()</code>可以获取中断标记的值，通过<code>Thread.interrupted()</code>返回当前线程的中断标记值并重置(清空，置为false)中断标记</li>
<li>目标线程对中断的响应<ul>
<li>无影响：目标线程在执行阻塞方法/操作</li>
<li>取消任务的运行：取消那一刻执行的任务，但并影响target继续执行其他任务</li>
<li>工作者线程停止：target线程的生命状态标记为<code>TERMINATED</code></li>
</ul>
</li>
<li>Java标准库的许多阻塞方法对中断的响应方式是：抛出<code>InterruptedException</code>等异常；有些阻塞方法无法响应中断，如：<strong>InputStream.read(), Lock.lock()以及内部锁的申请</strong><ul>
<li>响应中断的方法通常是在执行阻塞操作前判断中断标志，若中断标志为true，则抛出<code>InterruptedException</code></li>
<li>凡是抛出<code>InterruptedException</code>异常的方法，通常会在其抛出该异常之前将当前线程的线程中断标记重置为false，即调用<code>Thread.interrupted()</code>方法</li>
<li>能够响应中断的阻塞方法/操作而被暂停时，发起这些线程给这些方法的执行线程发送中断会导致Java虚拟机<strong>将响应的线程唤醒，并使其抛出<code>InterruptedException</code></strong></li>
</ul>
</li>
<li>对<code>InterruptedException</code>的处理<ul>
<li>不捕获，利用throws；捕获后重新抛给上层</li>
<li>捕获并中断当前线程，恢复中断标志</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">randomPause</span><span class="params">(<span class="keyword">int</span> maxPauseTime)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> sleepTime = rand.nextInt(maxPauseTime);</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Thread.sleep(sleepTime);</div><div class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">        Thread.currentThread().interrupt(); <span class="comment">// 保留线程中断标记</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>不能使用线程中断标记作为线程停止标记，需要专门的实例变量作为线程停止标记，</p>
<ul>
<li><p>通用的停止线程的方案：</p>
</li>
<li><p>生产者——消费者模式，生产者需先停止</p>
</li>
<li>web应用中的线程停止：</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java/multi-threads/Java并发编程实战/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="znewcradle">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Znewradle's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java/multi-threads/Java并发编程实战/" itemprop="url">Java并发编程实战</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T15:25:05+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/04/21/java/multi-threads/Java并发编程实战/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/04/21/java/multi-threads/Java并发编程实战/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="并发编程实战"><a href="#并发编程实战" class="headerlink" title="并发编程实战"></a>并发编程实战</h3><ol>
<li><p>挖掘可并发的点</p>
</li>
<li><p>分而治之：区分程序算法的并行部分和串行部分，用专门的线程去并发地执行可并发化的部分</p>
<ul>
<li>基于数据的分割：将程序的输入数据分解为若干规模较小的数据利用若干线程并发地处理这些分解后的数据</li>
<li>基于任务的分割：将任务分解为多个子任务，并分配若干工作者线程并发执行子任务</li>
</ul>
</li>
<li><p>基于数据的分割实现并发化</p>
<ul>
<li>基于数据分割，产生子任务，由专门的工作者线程负责执行，产生的是同质工作线程（任务处理逻辑相同）</li>
<li>示例：大文件下载器设计</li>
<li>需要考虑的问题<ul>
<li>工作者线程数量合理设置</li>
<li>工作者线程的异常处理</li>
<li>原始输入规模未知</li>
<li>程序复杂性增加（如何合并最后的结果）</li>
</ul>
</li>
</ul>
</li>
<li><p>基于任务的分割实现并发化——产生相互协作的异质工作线程</p>
<ul>
<li><p>按任务的资源消耗属性分割</p>
<ul>
<li>CPU密集型</li>
<li>I/O密集型</li>
<li>混合型任务，可能需要进一步分解</li>
<li>示例：日志处理</li>
<li>需要考虑的问题：同样可能导致程序的复杂性增加</li>
</ul>
<blockquote>
<p>从单线程出发进化到多线程版本，如果单线程算法本身没有重大性能瓶颈但仍然无法满足要求的情况下才使用多线程</p>
</blockquote>
</li>
<li><p>按处理步骤分割</p>
<ul>
<li>如果程序算法中存在一系列的步骤，为了提高程序的吞吐率，可以考虑为其中每一个处理步骤安排多个工作者线程负责相应的处理</li>
<li>按任务资源消耗属性分割可以被看做按处理步骤分割的一个特例；但是线程数过多会导致上下文切换频繁，反而降低了程序的吞吐率</li>
</ul>
</li>
</ul>
</li>
<li><p>合理设置线程数</p>
<ul>
<li>Amdahl’s定律：线程数与多线程程序相对于单线程程序的提速之间的关系<ul>
<li>最终决定多线程程序提速的因素是整个计算中串行部分的耗时比率，为使多线程提速，应从算法入手，减少程序必须串行的部分，而不是寄希望于增加线程数</li>
</ul>
</li>
<li>线程数设置的原则：<ul>
<li>系统处理器数目<code>int nCPU = Runtime.getRuntime().availableProcessors();</code></li>
<li>对于CPU密集型线程，可以将着泪线程数设置为N~cpu~个；由于CPU密集型线程可能因为某些原因被切出，为了避免处理器资源浪费，也可以为这类线程设置N~cpu~+1</li>
<li>对于I/O密集型线程，考虑I/O操作会导致上下文切换，如果设置过多则额外开销大，因此越少越好。如果一个工作者线程不够，可以考虑设置为2 * N~cpu~个，I/O线程等待过程不占用处理器资源，可以为每个处理器安排一个额外的线程以提高处理器资源的利用率</li>
<li>介绍wait time / service time的计算</li>
<li>从实践俩看，可以采用配置的方式或是在代码中自动计算来设置线程数，而不是将线程数硬编码在代码之中。</li>
</ul>
</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java/multi-threads/Java线程同步机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="znewcradle">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Znewradle's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java/multi-threads/Java线程同步机制/" itemprop="url">Java线程同步机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T15:22:02+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/04/21/java/multi-threads/Java线程同步机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/04/21/java/multi-threads/Java线程同步机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java线程同步机制"><a href="#Java线程同步机制" class="headerlink" title="Java线程同步机制"></a>Java线程同步机制</h2><blockquote>
<p>线程同步机制用于协调线程间的数据访问及活动机制，保障线程安全及实现这些线程的共同目标</p>
<p>同步机制：锁、volatile、final、static以及一些相关的API，如：Object.wait()/Object.notify()等</p>
</blockquote>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ol>
<li><p>将多个线程对共享数据的并发访问转换为串行访问——锁机制</p>
<ul>
<li><p>尝试进入临界区，申请锁 -》 申请锁，称为持有线程，执行临界区  -》 释放锁，离开临界区</p>
<blockquote>
<p>只能在临界区访问共享数据</p>
</blockquote>
</li>
<li><p>锁具有排他性，按JVM对锁实现方式的划分有：</p>
<ul>
<li>内部锁：synchronized</li>
<li>显式锁：java.concurrent.locks.Lock接口</li>
</ul>
</li>
<li><p>锁的作用，保障了</p>
<ul>
<li>原子性：互斥访问</li>
<li>可见性：写线程冲刷处理器缓存和读线程刷新处理器缓存，锁的获得隐含着刷新处理器缓存，在读之前同步更新写线程对共享变量的更新到该线程执行处理器的高速缓存中；锁的释放隐含着冲刷处理器缓存，使写线程对共享变量所做的更新能够被“推送”到该线程执行处理器的高速缓存中</li>
<li>有序性：保障可见性和原子性，使得写线程对共享变量的更新对读线程可见，读线程可以认为写线程是按照源码顺序更新上述共享变量，保障有序性</li>
<li>锁的保障有前提：同一把锁，读写线程都需要</li>
</ul>
</li>
<li><p>相关概念</p>
<ul>
<li>可重入性：一个线程在其持有一个锁时能够再次申请该锁（支持）</li>
<li>锁的争用与调度：内部锁是非公平锁，显式锁既支持公平锁又支持非公平锁</li>
<li>锁的粒度：锁的粒度由所保护的共享数据的数量大小决定</li>
</ul>
</li>
<li><p>锁的开销和问题：</p>
<ul>
<li>锁的申请和释放以及上下文切换造成开销</li>
<li>线程活性障碍：锁泄漏 + 死锁和锁死</li>
</ul>
</li>
</ul>
</li>
<li><p>内部锁synchronized</p>
<ul>
<li>synchronized修饰：同步方法，同步静态方法，同步实例方法，同步块</li>
<li>同步块</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">synchronized</span>(锁句柄) &#123;     <span class="comment">// 锁引导的同步块</span></div><div class="line">    <span class="comment">// 临界区</span></div><div class="line">&#125; <span class="comment">// 锁句柄通常用private final修饰</span></div></pre></td></tr></table></figure>
<ul>
<li>同步静态方法，相当于锁句柄是类对象</li>
<li>内部锁不会导致锁泄漏，不公平锁不保障被唤醒的线程就一定持有该锁</li>
</ul>
</li>
<li><p>显式锁：Lock接口</p>
<ul>
<li><code>ReentrantLock</code>是<code>Lock</code>接口的默认实现类，支持<code>lock(), lockInterruptibly(), newCondition(), tryLock(), tryLock(), unlock</code></li>
<li>创建Lock，默认ReentrantLock -&gt; 申请显式锁，Lock.lock() -&gt; 临界区中访问共享数据，可重入 -&gt; 释放锁Lock.unlock()，为了避免锁泄漏，将其放入finally中</li>
<li>显式锁支持公平和非公平锁：<code>ReentrantLock(boolean fair)</code>，true为公平锁<ul>
<li>公平锁适合锁被持有时间相对长或者线程申请所的平均时间相对长的情形，开销较非公平锁更大</li>
<li>内部锁简单易用不会导致锁泄漏但是无灵活性；显式锁灵活但容易被错用；显式锁的特性<ul>
<li><code>lock.tryLock()</code>如果获取到锁则返回true，否则不会暂停线程返回false；另一个重载方法<code>tryLock(long time, TimeUnit unit)</code></li>
<li>公平锁和非公平锁</li>
<li><code>lock.isLock()</code>可用于检测相应锁是否被某个线程持有</li>
</ul>
</li>
<li>默认情况用内部锁，仅在需要时才用显式锁</li>
</ul>
</li>
<li>改进锁型：读写锁——共享/排他锁<ul>
<li>允许多个读线程并发，一次只允许一个写线程，读写互斥</li>
<li>读锁：读线程共享，写线程排他；写锁：对读写线程都排他</li>
<li>读写锁抽象<code>ReadWriteLock</code>，定义了readLock()和writeLock()方法，分别返回读锁和写锁，默认实现类<code>ReentrantReadWriteLock</code></li>
<li>使用条件：只读操作比写操作要频繁很多；读线程持有锁的时间较长；否则，由于读写锁复杂的实现，性能开销大</li>
<li>ReentrantReadWriterLock支持锁的降级，即持有写锁后可以继续获得相应的读锁；但是不支持升级</li>
</ul>
</li>
<li>锁的适用场景<ul>
<li><code>check-then-act</code></li>
<li><code>read-modify-write</code></li>
<li>多个线程对多个共享数据及逆行更新，数据之间存在关联关系</li>
</ul>
</li>
</ul>
</li>
<li><p>内存屏障——底层帮助线程同步机制</p>
<ul>
<li>刷新处理器缓存保证了该锁的当前持有线程能够读取到前一个持有线程对这些数据所作的更新</li>
<li>冲刷处理器缓存保证了该所的当前持有线程对共享数据所做的更新对该锁后续持有线程可见</li>
<li>JVM底层借助内存屏障来实现刷新处理器缓存和冲刷处理器缓存，<strong>插入到两个指令之间使用，禁止编译器、处理器重排序保障有序性</strong>，其分类<ul>
<li>按照可见性保障来划分：加载屏障——刷新处理器缓存 and  存储屏障——冲刷处理器缓存</li>
<li>按照有序性保障来划分：获取屏障——在一个读操作之后插入该内存屏障；释放屏障——在写操作之前插入该内存屏障</li>
</ul>
</li>
</ul>
</li>
<li><p>volatile关键字</p>
<ul>
<li><p>用于修饰共享可变变量，对volatile变量的读写操作都是内存访问（高速缓存）操作；</p>
</li>
<li><p>其作用与锁作用相同的地方：保证可见性和有序性；但是在原子性方面，<strong>仅能保障写volatile变量操作的原子性，但没有锁的排他性</strong>；其使用不会引起上下文切换</p>
</li>
<li><p>volatile关键字在原子性方面仅保障被修饰的变量的读操作和写操作本身的原子性；但是赋值操作涉及到共享变量的访问会打破原子性</p>
</li>
<li><p>volatile如果修饰数组，只能保证对数组引用本身的操作起作用，无法对数组元素操作起作用；volatile的作用体现在其对所修饰的变量的读、写操作之上</p>
</li>
<li><p>对于引用型volatile变量，只保证读线程读取到一个指向对象的相对新的内存地址，而这个内存地址所指向的对象的实例/静态变量值是否是相对新的则没有保障</p>
</li>
<li><p>volatile的开销比锁小（不会引起上下文切换），介于临界区共享数据访问和普遍变量的写操作之间（因为volatile变量被放入高速缓存或者主存中而不是寄存器）</p>
</li>
<li><p>volatile的典型应用场景</p>
<ul>
<li>保障long/double类型变量的读、写操作的原子性</li>
<li>使用volatile变量作为状态标志（其他线程读取该状态并以此作为其计算的依据）</li>
<li>使用volatile保障可见性</li>
<li>使用volatile代替锁，将一系列可变状态变量封装成一个对象，对这些状态变量的更新可以通过创建新的对象并赋值给对应的引用型volatile变量（该过程保障原子性和可见性）</li>
<li>使用volatile实现简易版的读写锁</li>
</ul>
<blockquote>
<p>volatile适合多个线程共享一个状态变量（对象）；锁更适合多个线程共享一组状态变量</p>
</blockquote>
</li>
</ul>
</li>
<li><p>单例模式的多线程安全版本：</p>
<ul>
<li>延迟加载模式，利用<code>getInstance()</code>方法，判空返回实例化对象；但是可能引起竞态；加锁则影响性能</li>
<li>双重检查锁定（double-checked locking, DCL）</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DCLSingleton</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DCLSingleton instance;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DCLSingleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DCLSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</div><div class="line">            <span class="keyword">synchronized</span>(DCLSingleton.class) &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</div><div class="line">                    instance = <span class="keyword">new</span> DCLSingleton();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>基于竞态内部类的单例模式实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticHolderSingleton</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticHolderSingleton</span><span class="params">()</span> </span>&#123;</div><div class="line">        Debug.info(<span class="string">"StaticHolderSingleton inted."</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</div><div class="line"> 		<span class="keyword">final</span> <span class="keyword">static</span> StaticHolderSingleton INSTANCE = </div><div class="line">            <span class="keyword">new</span> StaticHolderSingleton();</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticHolderSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> InstanceHolder.INSTANCE;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 利用了竞态方法类调用时，JVM会初始化这个方法所访问的内部静态类InstanceHolder</span></div><div class="line">    <span class="comment">// 使InstanceHolder的静态变量INSTANCE被初始化，从而类唯一实例被创建，且仅一次</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li><p>CAS与原子变量</p>
<ul>
<li>CAS(Compare and Swap)是处理器指令，是一个原子的if-then-act操作；但是并不保障可见性</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 伪代码</span></div><div class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSwap</span><span class="params">(Variable V, Object A, Object B)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (A == V.get()) &#123; <span class="comment">// 检查变量的值是否被其他线程修改</span></div><div class="line">        V.set(B);     <span class="comment">// act：更新变量值 </span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;   <span class="comment">// 更新成功</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;         <span class="comment">// 变量值已被其他线程修改，更新失败</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>原子变量类（基于CAS实现的能够保障对共享变量进行read-modify-write更新操作的原子性和可见性的一组工具类）</li>
</ul>
</li>
</ol>
<p><img src="C:\Users\12874\OneDrive\MDpictures\notes\atom.png" alt="atomic variable class"></p>
<p>​    </p>
<ol>
<li>对象的发布与逸出<ul>
<li>对象发布：使对象能够被其作用域之外的线程访问<ul>
<li>共享private变量</li>
<li>将对象引用存储到public变量中</li>
<li>非private方法返回一个对象</li>
<li>创建内部类，使得当前对象能够被这个内部类使用</li>
<li>通过方法调用将对象传递给外部方法</li>
</ul>
</li>
<li>对象的初始化安全：final与static<ul>
<li>JVM加载类后，该类的所有静态变量仍旧是其默认值，直到有个线程初次访问该类的任意一个静态变量后才对这个类进行静态初始化</li>
<li>static在多线程环境下，能够保证一个线程即使在未使用其同步机制的情况下也总是可以读取到一个类的静态变量的初始值（不是默认值）。但是这种可见性仅限于线程初次访问该变量，此后仍旧需要借助同步机制</li>
<li>final保证对象被发布到其他线程时，该对象的所有final字段都是初始化完毕的，其他线程读取的是相应字段的初始值而不是默认值</li>
</ul>
</li>
<li>安全发布是指对象以线程安全的方式被发布，如果发布出现异常则称对象逸出</li>
</ul>
</li>
</ol>
<h4 id="对volatile的补充"><a href="#对volatile的补充" class="headerlink" title="对volatile的补充"></a>对volatile的补充</h4><ol>
<li>volatile的两层语义：<ul>
<li>保证了不同线程对于volatile变量进行操作时的可见性</li>
<li>禁止进行指令重排序（volatile变量访问语句的前后部分的语句不会发生交换，但是语句重排可以发生在前部分或者后部分自身）</li>
</ul>
</li>
<li><p>内存屏障的功能（对volatile变量的访问会引起汇编代码增加lock前缀指令，即内存屏障）：</p>
<ul>
<li>确保指令重排序时不会把后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面（执行到内存屏障这句指令时，前面的操作全部完成）</li>
<li>强制对缓存的修改操作立即写入主存</li>
<li>如果是写操作，导致其他CPU中对应的缓存无效</li>
</ul>
</li>
<li><p>应用场景</p>
<ul>
<li>使用volatile必须具备的2个条件：<ul>
<li>对变量的写操作不依赖于当前值</li>
<li>该变量没有包含在具有其他变量的不变式中</li>
</ul>
</li>
<li>volatile无法保证操作的原子性，所以要在能够保证操作原子性的基础上使用</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java/multi-threads/Java多线程基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="znewcradle">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Znewradle's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java/multi-threads/Java多线程基础/" itemprop="url">Java多线程基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T15:20:29+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/04/21/java/multi-threads/Java多线程基础/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/04/21/java/multi-threads/Java多线程基础/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h3><ol>
<li>进程是程序的运行实例，是资源分配的最小单位；线程是进程中可以独立执行的最小单位；一个进程可以包含多个线程；同一个进程中的所有线程共享该进程的所有资源。<strong>特定的线程执行特定的任务，任务代表线程要完成的工作</strong></li>
<li>多线程编程是以线程为基本抽象单位的一种编程范式</li>
</ol>
<h3 id="Java线程API"><a href="#Java线程API" class="headerlink" title="Java线程API"></a>Java线程API</h3><ol>
<li><p><code>java.lang.Thread</code>是Java对线程的实现，Thread类及其子类的一个实例就是一个线程；创建一个线程就是创建一个Thread类（及其子类）的实例，即：线程 = Thread实例，在Java中。</p>
<ul>
<li>run方法是线程任务处理逻辑的入口方法（Java虚拟机在运行时直接调用，不由应用代码调用），即：运行线程 = JVM执行该线程的run方法；<strong>run方法执行结束，相应的线程运行也就结束</strong></li>
<li>启动线程，实质是请求JVM运行相应的线程，线程何时运行由线程调度器(Scheduler)决定</li>
<li>创建线程<ul>
<li>利用<code>Thread()</code>，需覆盖run()方法实现任务处理逻辑；</li>
<li>利用<code>Thread(Runnable)</code>，传入实现Runnable接口的实例</li>
<li>两种创建方式的不同实际上就是：继承和组合技术的不同，组合方式更加灵活；Runnable是普通对象，能只用Runnable就可，则不要创建线程实例</li>
<li>Thread实际上实现了Runnable接口，从其实现源码可理解以上两种创建方式：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//From Thread </span></div><div class="line"><span class="comment">// target - Runnable</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</div><div class="line">        target.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>线程是“一次性用品”，不能重新调用已经运行结束的start方法，否则会抛出异常<code>IllegalThreadStateException</code></p>
</li>
<li><p>Java中线程的创建比对象创建代价更高，需要分配调用栈内存（跟踪调用关系和本地代码），且每个线程可能有一个内核线程对应；</p>
</li>
<li><p>Java中的任意一段代码都会由确定的线程负责执行；该线程也就是这段代码的执行线程。同一段代码可以被多个线程执行，通过<code>Thread.currentThread()</code>可以得到当前的执行线程，<strong>随着执行线程的不同返回的线程对象也不同</strong>。</p>
<ul>
<li>run方法也可以直接调用，但是此时的执行线程是调用者线程而不是新线程</li>
</ul>
</li>
<li><p>线程的属性：</p>
<ul>
<li>ID：long，只读，标识不同线程；唯一性只是一次运行有效</li>
<li>名称Name：String，可读性名称，为调试，建议设置有意义名称</li>
<li>线程类别Daemon：<code>boolean</code>类型，可以设置为true则变成守护线程；<code>setDaemon</code>方法必须在对start方法调用之前，否则抛出<code>IllegalThreadStateException</code></li>
<li>优先级Priority：<code>int</code>，线程调度器的提示，一般使用默认优先级</li>
</ul>
<blockquote>
<p>用户线程会阻止JVM正常停止，即JVM只有在所有用户线程运行结束后才会正常停止；而守护线程并不影响JVM的正常停止。因此，守护线程通常用于执行一些重要性不高的任务</p>
</blockquote>
</li>
<li><p>Thread类常用的方法：</p>
<ul>
<li><p><code>static Thread currentThread(), void static yield(),</code></p>
<p><code>void  static sleep(long mills)</code></p>
</li>
<li><p><code>run(), start()</code></p>
</li>
<li><p><code>join()</code>，A调用B的join，则A被挂起直到B运行结束；也就是调用join()方法的线程会继续运行，但是哪个线程中出现B.join()则该线程被</p>
</li>
</ul>
</li>
<li><p>Thread类的废弃方法：<code>stop, suspend, resume</code></p>
</li>
<li><p>线程的层次关系：</p>
<ul>
<li>Thread A创建了Thread B，则Thread A和Thread B构成父子线程关系</li>
<li>默认的，父线程和子线程在守护线程和用户线程上保持一致性；可以通过<code>setDaemon</code>来改变</li>
<li>子线程继承父线程的优先级</li>
<li>父子线程生命周期没有必然联系</li>
</ul>
</li>
<li><p>线程的生命周期：Thread.getState()返回Thread.State的枚举类型，可能的线程状态如下：</p>
<ul>
<li>NEW：创建而未启动；</li>
<li>RUNNABLE：拥有子状态READY和RUNNING<ul>
<li>READY：可以被Scheduler进行调度使之RUNNING</li>
<li>RUNNING：线程正在运行，线程可以之后转为READY(比如，调用Thread.yield)</li>
</ul>
</li>
<li>BLOCKED：线程发起阻塞I/O或申请由其他资源独占资源（锁），进行阻塞</li>
<li>WAITING：等待其他线程执行特定操作，更改为waiting状态的方法：wait, join, park；从WAITING到RUNNABLE可以调用对应的notify，notifyAll和unpark</li>
<li>TIMED_WAITING：与WAITING类似，是带有时间限制的等待状态，到期会自动转为RUNNABLE</li>
<li>TERMINATED：结束状态，只可能有一次处于该状态</li>
</ul>
<blockquote>
<p>一个线程整个lifetime，只可能处于NEW和TERMINATE状态一次</p>
</blockquote>
</li>
<li><p>线程的监视：</p>
<ul>
<li>主要是：获取并查看程序的线程转储，其中包含线程转储那一刻的线程信息（属性，生命周期状态，调用栈和锁等）</li>
</ul>
</li>
</ol>
<h2 id="多线程编程的目标与挑战"><a href="#多线程编程的目标与挑战" class="headerlink" title="多线程编程的目标与挑战"></a>多线程编程的目标与挑战</h2><ol>
<li>串行（单线串行）、并发（单线交替）与并行（多线同时）——多线程编程的实质是将任务处理的方式由串行改为并发，但是并非所有任务可并发化</li>
</ol>
<h3 id="竞态"><a href="#竞态" class="headerlink" title="竞态"></a>竞态</h3><ol>
<li>定义：<strong>计算结果的正确性与时间有关的现象</strong></li>
</ol>
<h4 id="二维表分析法：解释竞态的结果"><a href="#二维表分析法：解释竞态的结果" class="headerlink" title="二维表分析法：解释竞态的结果"></a>二维表分析法：解释竞态的结果</h4><ol>
<li>术语：<ul>
<li>状态变量：类的实例变量、静态变量；</li>
<li>共享变量：可以被多个线程共同访问的变量</li>
</ul>
</li>
<li>导致竞态的常见原因是：多个线程在没有采取任何控制措施的情况下并发地更新、读取同一个共享变量。<ul>
<li>竞态是指计算的正确性依赖于相对时间顺序或者线城的交错；竞态不一定导致计算结果的不正确，但是结果时而正确时而错误。</li>
<li>竞态往往伴随着读取脏数据(Dirty Read)</li>
</ul>
</li>
<li>竞态的模式与竞态产生的条件<ul>
<li>竞态的两种模式：read-modify-write（读-改-写）和check-then-act（检测而后行）<ul>
<li>read-modify-write：先读再修改后写回，这时可能存在脏读，读取了值后值被更新，写回的时候覆盖了上一次更新</li>
<li>check-then-act：读取某个共享变量的值，根据该变量的值决定下一步的动作，因为在读取之后，还是有其他线程会更新该变量的值</li>
<li>局部变量访问的是各自局部变量不会导致竞态</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h4><ol>
<li><p>定义：如果一个类在单线程环境下能够运作正常，并且在多线程环境下，在其使用方不必为其做任何改变的情况下也能运作正常，则线程安全，该类也具有线程安全性。</p>
</li>
<li><p>线程安全问题表现在3个方面：原子性、可见性和有序性</p>
</li>
<li><p>原子性：</p>
<ul>
<li><p>对于涉及共享变量访问的操作，该操作<strong>从其执行线程以外的任意线程来看</strong>是不可分割，则该操作是原子操作</p>
</li>
<li><p>原子操作是针对访问共享变量的操作而言的；涉及局部变量访问的操作无所谓是否是原子；原子操作只有在多线程环境下有意义</p>
</li>
<li><p>Java实现原子性的两种方式：</p>
<ul>
<li>使用锁Lock，具有排他性，消除竞态——软件层面</li>
<li>利用处理器提供的CAS（Compare-and-Swap）指令——硬件层面</li>
<li>在Java中，除了long和double以外的基础类型和引用类型变量的写操作都是原子的；针对任何变量的读操作都是原子操作。但是用<strong>volatile</strong>关键字修饰的long/double型变量的写操作具有原子性</li>
<li>volatile关键字仅能保障变量写操作的原子性，并不保障其他操作（read-modity-write操作和check-then-act）的原子性</li>
</ul>
</li>
</ul>
</li>
<li><p>可见性</p>
<ul>
<li><p>如果一个线程对某个共享变量进行更新之后，后续访问该变量的线程可以读取到该新的结果，则称<strong>该线程对该共享变量的更新对其他线程可见</strong>。</p>
<p>即，一个线程对共享变量的更新的结果对于读取相应共享变量的线程而言是否可见</p>
</li>
<li><p>两个线程分别运行在不同的处理器上，而这两个线程所共享的变量却被分配到寄存器上进行存储，就会产生可见性问题（但是共享变量被分配到内存上也不能保证该变量可见性——由于高速缓存子系统的存在（高速缓存，写缓冲器，无效优化队列等），一个处理器的写缓冲器中的内容无法被另一个处理器读取，因此运行在另一个处理器上的线程无法看到）</p>
</li>
<li><p>为了保障可见性，必须使一个处理器对共享变量所做的更新最终被写入该处理器的高速缓存中或主内存中（而不是始终停留在其写缓冲器中），即：冲刷处理器缓存。<strong>volatile关键字，就是提示JIT编译器被修饰的变量可能被多个线程共享，阻止JIT编译器做出可能导致程序运行不正常的优化，使相应的处理器执行刷新处理器的缓存的动作，从而保障写可见性。</strong></p>
</li>
<li><p>可见性的保障，意味着一个线程能够读取到共享变量的相对新值（一个线程更新该变量的值之后，其他线程能够读取到这个更新之后的值，则为相对新值），而非最新值（读线程排斥其他写线程，所读取的值）</p>
</li>
<li><p>Java语言规范保证：父线程在启动子线程之前对共享变量的更新对于子线程来说是可见的，线程终止后该线程共享变量的更新对于调用该线程的join方法的线程而言是可见的（因为调用join方法的线程会先结束，所以调用该线程的join方法线程是可见的），但是<strong>父线程在子线程启动后，对共享变量的更新对子线程的可见性没有保证</strong></p>
</li>
</ul>
</li>
<li><p>*有序性</p>
<ul>
<li>重排序：一个处理器上执行的多个操作，从其他处理器的角度来看，其顺序可能与目标代码所指定的顺序不一致</li>
<li>重排序是对内存访问（读写）所作的一种优化，在单线程下不影响程序正确性但是可能会对多线程程序的正确性产生影响，导致线程安全问题</li>
<li>源码顺序、程序顺序、执行顺序、感知顺序</li>
<li>指令重排序 —— 存储子系统重排序</li>
</ul>
</li>
<li><p>上下文切换：多个线程共享同意给处理器的产物，时间片的存在导致线程调度，需要上下文切换——切出和切入</p>
<ul>
<li>生命周期：从RUNNABLE状态与非runnable状态（blocked，waiting和timed_waiting中任意一个子状态）之间的切换，就是一个上下文切换的过程</li>
<li>线程暂停——由RUNABLE到非RUNNABLE；线程被唤醒——从非RUNNABLE到RUNNABLE状态</li>
<li>自发性上下文切换——非自发性上下文切换；上下文切换的开销导致多线程不一定就比单线程编程的计算效率高</li>
</ul>
</li>
<li><p>线程的活性故障：死锁、锁死、活锁、饥饿</p>
</li>
<li><p>资源争用与调度：</p>
<ul>
<li>排他性资源 &amp; 资源争用 （高争用 and 低争用 vs 高并发 and 低并发）</li>
<li>公平调度（不会饥饿但是吞吐率较小） vs 非公平调度（首选，吞吐率大，缺点是可能导致饥饿现象）</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java/jvm/虚拟机类加载机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="znewcradle">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Znewradle's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java/jvm/虚拟机类加载机制/" itemprop="url">虚拟机类加载机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T10:51:11+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/04/21/java/jvm/虚拟机类加载机制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/04/21/java/jvm/虚拟机类加载机制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>JVM的类加载机制：把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可被虚拟机直接使用的Java类型</p>
<p>类加载、连接和初始化过程都是在程序运行期间完成的；虽有性能开销，但是由于运行期加载和动态连接使得可以动态扩展语言</p>
<h4 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h4><blockquote>
<p> 从加载到内存到卸载出内存，整个生命周期包括7个阶段：加载、验证、准备、解析、初始化、使用和卸载。其中，<strong>验证、准备和解析</strong>统称为连接。</p>
<ol>
<li>加载、验证、准备、初始化和卸载5个阶段顺序是确定的。解析阶段可以在初始化阶段之后再开始，支持动态绑定。</li>
</ol>
</blockquote>
<ol>
<li><p>VM规范规定了有且有5种情况必须立即对类进行初始化（则加载、验证、准备也需发生）</p>
<ul>
<li>遇到new\getstatic\putstatic\invokestatic这4条字节码指令，且类没有进行初始化（被final修饰的常态字段除外，因为已在编译器把结果放入常量池的静态字段外）</li>
<li>使用<code>java.lang.reflect</code>包的方法对类进行反射调用，且类没有初始化</li>
<li>初始化一个类时，其父类还没有初始化</li>
<li>虚拟机启动时，需要指定一个要执行的主类（main()方法），需要初始化主类</li>
<li>使用JDK1.7动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果<code>REF_getStatic, REF_putStatic, REF_invokeStatic</code>的方法句柄，且方法句柄对应的类没有进行过初始化</li>
<li>接口也有初始化过程，但是其初始化时，并不要求其父接口全部完成了初始化，只有真正用到父接口时才会初始化</li>
</ul>
</li>
</ol>
<h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><p>加载、验证、准备、解析和初始化</p>
<ol>
<li><p>加载</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流(灵活性大，可以从zip，网络，运行时计算、其他文件生成、数据库中读取)</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据<br>的访问入口</li>
</ul>
<p>(数组本身不通过类加载器创建，默认由JVM直接创建，但是数组类的元素类型最终需要类加载器创建；数组的组件是引用类型则需要递归加载组件，可见性与组件类型一致；如果基础类型则默认public，JVM会将数组标记为与引导类加载器关联)</p>
</li>
<li><p>验证</p>
<ul>
<li>确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。如果验证到违反约束，则抛出<code>java.lang.VerifyError</code>异常或其子类异常</li>
<li>文件格式验证：<strong>验证字节流是否符合Class文件格式的规范</strong>，并且可被当前版本的VM处理；通过验证后，字节流进入内存的方法区中存储，其他验证阶段基于方法区存储结构进行，不会在直接操作字节流；</li>
<li>元数据验证：对字节码描述信息进行予以分析，确保其描述信息符合规范（类元信息）</li>
<li>字节码验证：通过数据流和控制流分析确定程序语义是合法、符合逻辑的；对类的方法体进行校验分析，确保被校验类的方法在运行时不会做出危害虚拟机安全的事件。</li>
<li>符号引用验证：将符号引用转化为直接引用，对类自身以外的信息进行匹配性校验；确保解析动作能正常执行，否则抛出<code>java.lang.IncompatibleClassChangeError</code>异常的子类</li>
</ul>
</li>
<li><p>准备</p>
<ul>
<li>为类变量分配内存并设置类变量初始值阶段（仅为static类变量），所用内存在方法区中进行分配，通常初始为零值。</li>
<li>如果类字段属性表中存在ConstantValue，则准备阶段value会被初始化为ConstantValue属性所指定的值。</li>
</ul>
</li>
<li><p>解析</p>
<ul>
<li>虚拟机将常量池内的符号引用替换为直接引用的过程<ul>
<li>符号引用：以一组符号来描述所用的目标，只要无歧义定位到目标即可；符号引用与虚拟机实现的内存布局无关，引用目标不一定已经加载到内存中</li>
<li>直接引用：可以直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，和内存布局相关。（同一个符号引用在不同VM上翻译出来的直接引用一般不同）</li>
</ul>
</li>
<li>虚拟机可以对第一次解析结果进行缓存，静态解析第一次解析成败决定之后是否抛出异常</li>
<li><code>invokedynamic</code>指令，用于支持动态语言，在运行时进行解析动作；其余为静态指令（可以在刚加载完成还没开始执行代码时就进行解析）</li>
<li>主要针对：接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用<ul>
<li>类或接口解析：假设当前代码所处的类为D，把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，则：<ul>
<li>C不是数组，VM将N的全限定名传递给D的类加载器去加载C</li>
<li>C是数组且数组类型为对象，则按照👆加载数组元素类型，解这VM生成代表此数组维度和元素的数组对象</li>
<li>👆完成后，C有效，还要进行符号引用验证，确认D对C的访问权限</li>
</ul>
</li>
<li>字段解析：字段所属的类或接口用C表示，如果C本身包含简单名称和字段描述符斗鱼目标相匹配的字段，则返回字段的直接引用；否则如果实现接口则按继承关系从下往上递归搜索各个接口和父接口；如果C不是Object则会按继承关系从下往上递归搜索父类；否则查找失败，抛出异常</li>
<li>类方法解析：先解析出类方法表的class_index项中索引的方法所属的的类或接口的符号引用<ul>
<li>类方法和接口方法符号引用的常量类型定义是分开的，在类方法表中发现class_index中索引是个接口，抛出<code>java.lang.IncompatibleClassChangeError</code></li>
<li>查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回该方法引用</li>
<li>否则，在父类中递归查找是否有匹配的方法；</li>
<li>否则，在类C实现的接口列表及它们的父接口之中递归查找</li>
<li>否则，查找失败，抛出<code>java.lang.NoSuchMethodError</code></li>
</ul>
</li>
<li>接口方法解析：先解析接口方法表的<code>class_index</code>项中索引的方法所属的类或接口的符号引用<ul>
<li>在接口方法表中发现类索引C是类，则抛出<code>IncompatibleClassChangeError</code></li>
<li>否则，在接口中查找是否有简单名称和描述符都与目标匹配的方法，如果有则返回该方法的直接引用；</li>
<li>否则，在接口C的父接口中递归查找，直到Object；</li>
<li>否则，查找失败，抛出<code>java.lang.NoSuchMethodError</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>初始化</p>
<ul>
<li><p>准备阶段，变量已按系统要求赋过初始值；初始化阶段，则根据程序员的代码去初始化类变量和其他资源，即执行类构造器<code>&lt;clinit&gt;()</code>方法</p>
</li>
<li><p><code>&lt;clinit&gt;()</code>方法由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}）中的语句合并产生</p>
<ul>
<li>收集顺序由语句在源文件中出现的顺序所决定</li>
<li>static语句块中只能访问到定义在static语句块之前的变量；定义在之后的变量可以赋值但不能访问</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        i = <span class="number">0</span>;     <span class="comment">// 可以赋值</span></div><div class="line">        System.out.println(i);  <span class="comment">// "非法向前引用"，即不能访问</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><code>&lt;clinit&gt;()</code>方法与类的构造函数<code>&lt;init&gt;()</code>方法不同，不用显式调用父类构造器，VM保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕- -<ul>
<li>Object类的<code>&lt;clinit&gt;()</code>方法第一个被执行</li>
<li>父类中定义的静态语句块要优先于子类的变量赋值操作</li>
</ul>
</li>
<li><code>&lt;clinit&gt;()</code>方法并非必需，即类中没有静态语句块 +  对变量的赋值操作；则编译器不为此类生成该方法</li>
<li>接口有赋值操作仍有<code>&lt;clinit&gt;()</code>方法，但是不需先执行父接口的<code>&lt;clinit&gt;()</code>方法，只有当父接口中定义的变量使用时，其才会被初始化。<strong>接口的实现类，同</strong></li>
<li>VM会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确加锁、同步，保证只有一个线程执行类的<code>&lt;clinit&gt;()</code>方法，其他阻塞</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ol>
<li><p>类加载器：通过一个类的全限定名来获取此类的二进制字节流的代码模块</p>
<ul>
<li>任意一个类，都需要加载它的类加载器和这个类本身以统确立其在JVM中的唯一性</li>
<li>只有两个类由同一个类加载器加载才能比较是否相等<code>equals()/ isAssignableFrom()/ isInstance()</code>的返回结果</li>
</ul>
</li>
<li><p>双亲委派模型（JVM角度，只有两种不同的类加载器）</p>
<ul>
<li>启动类加载器(Bootstrap ClassLoader)用C++实现，是虚拟机自身的一部分<ul>
<li>负责将存放在<code>&lt;JAVA_HOME&gt;\bin</code>目录中，或者被<code>-Xbootclasspath</code>参数指定的路径，并且是虚拟机识别的类库加载到虚拟机内存中（启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可）</li>
</ul>
</li>
<li>其他类加载器由Java实现，独立于虚拟机外部，并且全部继承自抽象类<code>java.lang.ClassLoader</code><ul>
<li>扩展类加载器：由<code>sun.misc.Launcher$ExtClassLoader</code>实现，负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库（开发者可以直接使用）</li>
<li>应用程序类加载器：系统类加载器，负责加载用户类路径上所指定的类库，开发者可以直接使用（如果没有自定义类加载器，则为默认的类加载器）</li>
</ul>
</li>
<li>类加载器之间的层次关系，为类加载器的双亲委派模型：除了启动类加载器外，其余类都应当有自己的父类加载器（一般使用组合关系复用父加载器的代码）</li>
</ul>
<p><img src="https://uocd4w.ch.files.1drv.com/y4mcda8QG4fMGv0CEsY0C_dov5SztHIQmLC9QwKIlkzv5pfshCA8uot-XuDftPqQBxr0HDDx1B--vhysuIIDyVmTwTh8zrLV0zYa1s_Sb1EcYBb5terEmVGtPiV5hbcTu1A03QrNQmaL1UsfP7wjPz_vGnb90vHz_XnIm1Cia0lm0GIoGmxkgIH0acsJvkpWAZuXB0ut-dBZDbIiB8lLm60IA?width=544&amp;height=482&amp;cropmode=none" alt="class loader"></p>
<ul>
<li>双亲委派模型的工作过程：类加载器收到了类加载请求后，首先该请求委派给父类加载器 -&gt; 所有的加载请求最终都会传送到顶层的启动类加载器 -&gt; 只有父类无法完成时，子加载器才会尝试自己加载<ul>
<li>好处：Java类随着类加载器一起具备带有优先级的层次关系（比如，Object类在程序的各种类加载器环境中都是同一个类）</li>
<li>实现：集中在<code>java.lang.ClassLoader#loadClass()</code>方法中，如下：</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</div><div class="line">    <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</div><div class="line">        <span class="comment">// 首先，检查请求的类是否已经被加载过</span></div><div class="line">        Class&lt;?&gt; c = findLoadedClass(name);</div><div class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</div><div class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    c = findBootstrapClassOrNull(name);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">                <span class="comment">// ClassNotFoundException thrown 如果父类加载器抛出</span></div><div class="line">                <span class="comment">// 说明服父类加载器无法完成加载请求</span></div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">// 在父类加载器无法加载的时候，再调用本身的的findClass方法进行类加载</span></div><div class="line">                <span class="keyword">long</span> t1 = System.naoTime();</div><div class="line">                c = findClass(name);</div><div class="line">                </div><div class="line">                <span class="comment">// this is the defining class loader; record the stats</span></div><div class="line">          sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</div><div class="line">           sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</div><div class="line">                sun.misc.PerfCounter.getFindClasses().increment();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> c;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>破坏双亲委派模型</p>
<ul>
<li><p>双亲委派模型之前</p>
<ul>
<li><p>用户可以继承<code>ClassLoader</code>并重写protected的loadClass()方法</p>
</li>
<li><p>JDK1.2之后，不提倡覆盖loadClass()方法，应当把类加载逻辑写到<code>findClass()</code>方法中，在<code>loadClass()</code>方法的逻辑里如果父类加载失败，则会调用自己的findClass()方法</p>
</li>
</ul>
</li>
<li><p>自身缺陷</p>
<ul>
<li>为解决<strong>基础类调用回用户的代码</strong>，如<code>JNDI</code>；在线程上下类加载器可以通过<code>java.lang.Thread</code>类的<code>setContextClassLoader()</code>方法进行设置</li>
</ul>
</li>
<li><p>用户对程序动态性的追求：OSGi，每个模块(Bundle)都有自己的类加载器并按照以下顺序进行类搜索：</p>
<ul>
<li>将以<code>java.*</code>开头的类委派给父类加载器加载；</li>
<li>否则，将委派列表名单内的类委派给父类加载器加载；</li>
<li>否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载</li>
<li>否则，查找当前的Bundle的ClassPath，使用自己的类加载器加载</li>
<li>否则，查找类是否在自己的Fragment Bundle中；如果在，则委派给Fragment Bundle的类加载器加载</li>
<li>否则，查找Dynamic Import列表的Bundle，委派给对应的Bundle的类加载器加载</li>
<li>否则，类查找失败</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="第八章-虚拟机字节码执行引擎"><a href="#第八章-虚拟机字节码执行引擎" class="headerlink" title="第八章 虚拟机字节码执行引擎"></a>第八章 虚拟机字节码执行引擎</h3><p>####　概述</p>
<ol>
<li>虚拟机的执行引擎由自己实现，可以自行制定指令集与执行引擎的结构体系，并且能够执行不被硬件直接支持的指令集格式</li>
<li>JVM的执行引擎：输入字节码 -&gt;  处理执行 -&gt; 输出执行结果</li>
</ol>
<h4 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h4><blockquote>
<p>栈帧信息：动态连接 + 方法返回地址 +其他附加信息（ＶＭ添加规范中没有的描述信息）</p>
</blockquote>
<ol>
<li>栈帧：支持虚拟机进行方法调用和方法执行的数据结构，VM运行时数据区中的虚拟机栈的栈元素<ul>
<li>存储方法的局部变量表、操作数栈、动态连接和方法返回地址</li>
<li>每个方法的调用开始至执行完成 &lt;-&gt; 栈帧在VM栈中入栈到出栈</li>
<li>只有位于栈顶的栈帧，即当前栈帧是有效的，与之关联的方法为当前方法（执行引擎运行的所有字节码指令都只对当前栈帧进行操作）</li>
</ul>
</li>
<li>局部变量表<ul>
<li>存放方法参数和方法内部定义的局部变量，以变量槽(Variable Slot)为最小单位（Slot的长度随着处理器、操作系统或虚拟机的不同而发生变化；一个Slot可以存放32位以内的数据类型：<code>boolean, byte, char,  short, int, float, reference和returnAddress</code>，其中，reference类型表示对对象实例的引用，可以直接或间接找到对象在堆中的数据存放的起始地址索引；查到对象所属数据类型在方法区中的存储的类型信息。returnAddress原用来处理异常，现在由异常表代替）</li>
<li>对于64位数据(long, double)，VM会高位对齐，连续分配两个slot空间；局部变量表简历在线程堆栈上，是线程私有数据，不会引起数据安全问题。但是存放64位的两个slot，不允许单独访问其中一个，某则会在类加载的校验阶段抛出异常</li>
<li>局部变量表中第0位索引的Slot默认用于传递方法所属对象实例的引用，即this引用；之后是传递给方法的参数；最后是方法体内按顺序定义的变量</li>
<li>局部变量表中的slot可复用，如果某个变量超过其作用域，则可以交给其他变量使用 <ul>
<li>变量超过其作用域后，占用的Slot不会立即被回收；只有当新的变量请求slot空间时，才会对其回收。所以，对于占用大量内存，实际上不会再使用的变量，手动将其设置为null值，<strong>但是最好是通过变量作用域控制变量回收时间</strong>（因为JIT编译器在优化过程可能会将赋null值的操作消除）</li>
<li>局部变量如果没有赋初始值则不能使用，不是任何情况下变量都有默认赋值</li>
</ul>
</li>
</ul>
</li>
<li>操作数栈<ul>
<li>操作数栈的最大深度也在编译的时候写入到Code属性的<code>max_locals</code>数据项中<ul>
<li>方法刚执行，操作数栈为空，在方法执行过程中，字节码指令对其进行读取和写入（如：算术运算，调用方法传参）</li>
<li>大多VM会令两个栈帧出现一部分重叠 ，方便共享数据，无需额外复制</li>
</ul>
</li>
</ul>
</li>
<li>动态连接<ul>
<li>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，为支持方法调用过程中的动态连接。<ul>
<li>静态解析：在类加载阶段或者第一次使用时将符号引用转化为直接引用</li>
<li>动态连接：在运行期间将符号引用转化为直接引用</li>
</ul>
</li>
</ul>
</li>
<li>方法返回地址<ul>
<li>正常完成出口：执行引擎遇到任意一个方法返回的字节码指令，可能会有返回值传递给上层的方法调用者</li>
<li>异常完成出口：方法执行过程中有未得到处理的运行时异常，用throw抛出的异常且本方法的异常表中没有搜索到匹配的异常处理器</li>
<li>方法退出后，都需要返回到方法被调用的位置，可能需要在栈帧中保存信息帮助恢复上层方法的执行状态（方法退出的过程实际上就等同当前栈帧出栈）</li>
</ul>
</li>
</ol>
<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><blockquote>
<p>方法调用唯一任务是<strong>确定被调用方法的版本</strong>，暂时不涉及方法内部的具体运行过程。方法调用在Class文件中存储的只是符号引用，而不是实际运行时内存布局中的入口地址（直接引用）—— 提供了动态扩展能力</p>
</blockquote>
<ol>
<li><p>解析</p>
<ul>
<li>方法在程序真正运行之前就有确定的调用版本，并且方法的调用版本在运行期间不可变——在类加载阶段解析，主要包括<strong>静态方法和私有方法</strong>（都不能重写）<ul>
<li>JVM提供5条方法调用指令：<code>invokestatic</code>，<code>invokespecial</code>(实例构造器<init>方法、私有方法、父类方法)，<code>invokevirtual</code>虚方法，<code>invokeinterface</code>接口方法，<code>invokedynamic</code>运行时动态解析出调用点限定符所引用的方法</init></li>
<li>只有被<code>invokestatic</code>和<code>invokespecial</code>指令调用的方法在类加载阶段解析，符合条件的有<strong>静态方法、私有方法、实例构造器、父类方法</strong>——非虚方法；其余为虚方法（除去final方法，通过<code>invokevirtual</code>调用，但是非虚方法）</li>
</ul>
</li>
</ul>
</li>
<li><p>分派</p>
<ul>
<li><p>静态分派：以来静态类型来定位方法执行版本的分派动作——方法重载</p>
<ul>
<li>静态类型（外观类型）：在使用时发生变化，静态类型不会被改变，在编译期可知</li>
<li>实际类型：在运行期才确定<code>Human man = new Man();</code></li>
<li>（编译器）重载是通过<strong>参数的静态类型</strong>而不是实际类型作为判定依据；确定更加合适的版本：<code>char -&gt; int -&gt;  long -&gt; float -&gt; double -&gt; 装箱类型 -&gt; Serializable</code></li>
<li>静态方法也有重载版本，同样也是通过静态分派选择重载版本</li>
</ul>
</li>
<li><p>动态分派：与多态性有关——重写</p>
<ul>
<li><p><code>invokevirtual</code>指令的动态查找</p>
<ol>
<li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C</li>
<li><p>如果在类型C中找到与常量中的描述父和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回<code>java.lang.IllegalAccessError</code>异常</p>
</li>
<li><p>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程</p>
</li>
<li>如果始终没有找到合适的方法，则抛出<code>java.lang.AbstractMethodError</code></li>
</ol>
</li>
<li><p>从Step 1可以看出，在运行期确定接收者的实际类型，将常量池符号中的类方法符号引用解析到不同的直接引用上</p>
</li>
</ul>
</li>
<li><p>单分派与多分派</p>
<ul>
<li>宗量：方法的接收者与方法的参数统称</li>
<li>单分派：根据一个宗量对目标方法进行选择；多分派：根据多于一个宗量对目标方法进行选择</li>
<li>静态多分派、动态单分派</li>
<li>虚拟机动态分派：为类在方法区中简历虚方法表，使用虚方法索引来代替元数据查找，存放各个方法的实际入口地址，如果方法在子类中没有被重写，那么子类的虚方法表中存放父类相同方法的地址入口</li>
</ul>
</li>
</ul>
</li>
<li><p>动态类型语言支持(invokedynamic)</p>
<ul>
<li>动态类型语言：类型检查的主体过程在运行期而不是编译期；静态类型语言：在编译期进行类型检查过程</li>
<li><code>java.lang.invoke</code>提供动态确定目标方法的机制，即<code>MethodHandle</code><ul>
<li>Reflection(反射)机制是在Java代码层次重量级模拟方法调用，包含各种运行期信息；</li>
<li><code>MethodHandle</code>则是在字节码层面上轻量级模拟方法调用，仅包含执行盖方法相关的信息（可以服务于JVM之上的各种语言）</li>
</ul>
</li>
<li><code>invokedynamic</code>指令，为解决原有<code>invoke*</code>在JVM中固化，为高层实现提供基础<ul>
<li>抵押给参数<code>CONSTANT_InvokeDynamic_info</code>，可以得到引导方法(Bootstrap Method)，方法类型(MethodType)和名称；</li>
<li>引导方法有固定参数，返回真正要执行的目标方法调用</li>
</ul>
</li>
<li>掌控方法分派规则：</li>
</ul>
</li>
</ol>
<h3 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h3><h4 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h4><p>只有确定Java实现版本和执行引擎运行模式，才能确定Class文件中的代码是解释执行还是编译执行</p>
<h4 id="基于栈的指令集与基于寄存器的指令集"><a href="#基于栈的指令集与基于寄存器的指令集" class="headerlink" title="基于栈的指令集与基于寄存器的指令集"></a>基于栈的指令集与基于寄存器的指令集</h4><ol>
<li>基于栈的指令集主要的优点是可移植，寄存器由硬件直接提供；寄存器的指令集则受硬件的约束。但是执行速度相对稍慢。</li>
<li>栈架构的指令集，则代码更加紧凑，编译器实现更加简单；因为出栈和入栈产生相当多的指令数，有更频繁的内存访问</li>
</ol>
<h4 id="基于栈的解释器执行过程"><a href="#基于栈的解释器执行过程" class="headerlink" title="基于栈的解释器执行过程"></a>基于栈的解释器执行过程</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java/jvm/虚拟机执行子系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="znewcradle">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Znewradle's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java/jvm/虚拟机执行子系统/" itemprop="url">虚拟机执行子系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T10:48:34+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/04/21/java/jvm/虚拟机执行子系统/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/04/21/java/jvm/虚拟机执行子系统/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="虚拟机执行子系统"><a href="#虚拟机执行子系统" class="headerlink" title="虚拟机执行子系统"></a>虚拟机执行子系统</h2><h3 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h3><h4 id="无关性的基石"><a href="#无关性的基石" class="headerlink" title="无关性的基石"></a>无关性的基石</h4><ol>
<li><p>语言无关性的基础是：虚拟机和字节码存储格式；</p>
<ul>
<li><p>JVM与语言无关，只与Class文件特定的二进制文件格式所关联</p>
</li>
<li><p>Class文件中包含了JVM指令集和符号表以及若干辅助信息</p>
</li>
</ul>
</li>
</ol>
<h4 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h4><ol>
<li>任何一个Class文件都对应着唯一一个类或接口的定义信息（磁盘中）；但是类或接口并不一定都需定义在文件中（可以通过类加载器直接生成，在内存中）<ul>
<li>Class文件是一组以8字节为基础单位的二进制流；</li>
<li>数据项目严格按照顺序紧凑排列在Class文件之中，中间没有分隔符；（存储的内容几乎全是程序运行的必要数据，没有空隙，格式严格限定）</li>
<li>8位字节以上空间的数据项，会按照高位在前的方式分割成若干个8位字节进行存储</li>
<li>Class文件格式（类似C语言结构体的伪结构）只有两种数据类型：无符号数和表<ul>
<li>无符号数：基本数据类型，用u1, u2, u4, u8表示1，2，4，8个字节无符号数；可用来描述数字、索引引用、数量值以及按照UTF-8编码构成字符串值</li>
<li>表：多个无符号数或其他表作为数据项构成的复合数据类型，习惯性用_info结尾（描述有层次关系的复合结构的数据，整个Class文件本质上是一张表）</li>
</ul>
</li>
</ul>
</li>
<li>魔数与Class文件的版本<ul>
<li>Class文件的头4个字节称为魔数，确定该文件是否能偶被虚拟机接受（并非使用文件扩展名来识别文件，鉴于扩展名可以随意改动），Java的魔数是：<code>0xCAFEBABE</code></li>
<li>第5和6个字节是Class文件的次版本号，第7和8个字节是主版本号，（JDK版本号从45开始，如JDK1.0-11使用了45.0-45.3的版本号），高版本的JDK能够向下兼容低版本Class文件，反之则不行</li>
</ul>
</li>
<li>常量池<ul>
<li>紧接着版本号之后是常量池入口——Class文件之中的资源仓库（Class文件结构中与其他项目相关联最多的数据类型，占用Class文件空间最大的数据项目之一，Class文件中第一个出现的表类型数据项目）</li>
<li>常量池入口放置u2类型数据达标常量池容量的计数值（计数从1开始），第0项常量用于满足某些指向常量池的索引值的数据需要表达不引用任何一个常量池项目；<strong>其他集合类型则从0开始</strong></li>
<li>主要存放：<strong>字面量和符号引用</strong><ul>
<li>字面量：近似于常量，如字符串，final常量等</li>
<li>符号引用：类和接口的全限定名、字符的名称和描述符、方法的名称和描述符</li>
</ul>
</li>
<li>JVM在加载Class文件时进行动态连接，Class文件不会保存各个方法、字段的最终内存布局信息；常量池中每一项常量都是一个表，共有14中类型（JDK7之前是11种）<ul>
<li>UTF-8编码字符串，整型字面量、浮点型字面量</li>
<li>长整型字面量、双精度浮点型字面量、表示方法的句柄、标识方法类型等</li>
</ul>
</li>
<li>计算常量池的常量以及常量项的结构</li>
</ul>
</li>
<li>访问标志<ul>
<li>常量池结束后，紧接着的两个字节为访问标志(access_flags)，用于识别一些类或者接口层次的访问信息<ul>
<li>类或者接口</li>
<li>是否为public类</li>
<li>是否为abstract类型</li>
<li>如果是类是否被声明为final等</li>
</ul>
</li>
</ul>
</li>
<li>类索引、父类索引与接口索引集合<ul>
<li>类索引和父类索引均为u2类型数据，接口索引集合是一组u2类型的数据集合；Class文件中由这三项数据来确定类的集成关系；<ul>
<li>类索引：确定类的全限定名</li>
<li>父类索引：确定类的父类的全限定名（除了java.lang.Object之外，所有Java类的父类索引都不为0）</li>
<li>接口索引集合：描述这个类实现的接口集合，按顺序从左到右</li>
<li>类索引和父类索引两个u2类型索引各自指向一个类型为<code>CONSTANT_Class_info</code>的类描述符常量，通过<code>CONSTANT_Class_info</code>类型 的常量中的索引值可以找到定义在<code>CONSTANT_Utf8_info</code>类型的常量中的全限定名字符串</li>
</ul>
</li>
</ul>
</li>
<li>字段表集合<ul>
<li>用于描述接口或者类中声明的变量，包括类级变量 +　实例级变量（不包括方法中定义的局部变量）</li>
<li>字段表结构中包含了字段：<code>access_flags(访问权限、可变性和并发可见性), name_index（常量池引用，字段的简单名称）, attributes, attributes_count, descriptor_index（字段和方法的描述符）</code></li>
<li>字段表集合不会列出从超类或者父接口中继承而来的字段</li>
</ul>
</li>
<li>方法表集合<ul>
<li>存储对方法的描述和对字段的描述几乎一致；包括：访问标志、名称索引、描述符索引、属性表集合</li>
<li>子类没有重写的父类方法不出现，但是可能会出现编译器自动添加的方法，典型的如：<code>&lt;clinit&gt;和&lt;init&gt;</code></li>
</ul>
</li>
<li>属性表集合<ul>
<li>VM规范中预定义的属性，每个属性其名称需要从引用常量池<code>CONSTANT_Utf8_info</code>类型的常量来表示，属性值的结构则完全自定义，只需要通过u4的长度属性说明属性值所占用的位数</li>
<li>Code属性：存储方法体中的代码经Javac编译处理后的字节码，接口或抽象类中的方法则不存在<ul>
<li><code>attribute_name_index</code>：指向<code>CONSTANT_Utf8_info</code>型常量的索引，常量值固定为”Code”，<code>attribute_length</code>指示属性值的长度。</li>
<li><code>max_stack</code>代表操作数栈深度的最大值，方法执行的任意时刻操作数栈都不会超过该深度</li>
<li><code>max_locals</code>代表局部变量表所需的存储空间，其单位为Slot（虚拟机为局部变量分配内存所使用的最小单位，除了long和double需2个Slot，其余都是1个Slot）。存储方法参数、显式异常处理器参数、方法体中定义的局部变量；所有之和为<code>max_locals</code>。局部变量表中的Slot可以重用，故Javac会根据变量的作用域来分配Slot来给各个变量使用</li>
<li><code>code_length</code>和code用来存储编译后的字节码指令；每个指令是u1类型的单字节（JVM定义了约200条编码值对应的指令含义）；<code>code_length</code>是一个u4，但明确限制方法不允许超过65535条字节指令</li>
<li>实例方法通过this访问对象，是通过方法进行的，因此在实例方法的局部变量表中至少会存在一个指向当前对象实例的局部变量</li>
<li>字节码指令后是方法的显式异常处理表集合（并非必须），编译器使用异常表而不是简单的跳转命令来实现Java异常及finally处理机制</li>
</ul>
</li>
<li>Exceptions属性<ul>
<li>与异常表不同，意在列举出方法中可能抛出的受查异常（方法描述时在throws关键字后列出的异常）</li>
<li>Exceptions属性表</li>
</ul>
</li>
<li><code>LineNumberTable</code>属性<ul>
<li>描述Java源码行号与字节码行号（字节码偏移量）之间对应关系</li>
<li>通过<code>-g:none/ -g:lines</code>来取消或显示</li>
</ul>
</li>
<li><code>LocalVariableTable</code>属性<ul>
<li>用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系</li>
<li>通过<code>-g:noe/ -g:vars</code>来取消或显示</li>
</ul>
</li>
<li><code>SourceFile</code>属性：记录生成这个Class文件的源码文件名称</li>
<li><code>ConstantValue</code>属性：通知虚拟机自动为静态变量赋值，只有static修饰的变量会使用到</li>
<li><code>InnerClasses</code>属性：记录内部类与宿主类之间的关联</li>
<li><code>Deprecated</code>及<code>Synthetic</code>属性都属于标志类型的布尔属性，<ul>
<li><code>Deprecated</code>用于表示某个类、字段或者方法，已经被程序作者定位不再推荐使用</li>
<li><code>Synthetic</code>属性代表此字段或者方法并不由Java源码直接产生，而是由编译器自行添加</li>
</ul>
</li>
<li><code>StackMapTable</code>属性：变长属性，在Code属性的属性表中，在虚拟机类加载的字节码验证阶段被新类型检查验证器使用</li>
<li><code>Signature</code>属性：记录泛型签名信息，为了弥补擦除后，能够在运行期反射时获得泛型信息（JDK1.5之后）</li>
<li><code>BootstrapMethods</code>属性：变长属性，用于保存<code>invokedynamic</code>指令引用的引导方法限定符</li>
</ul>
</li>
</ol>
<h4 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h4><ol>
<li>JVM指令由操作码（OpCode, 一个字节） + 操作数（Operands, 0-n）；大多数指令不包含操作数，只有一个操作码<ul>
<li>字节码指令集中，操作码一个字节总数不超过256条；</li>
<li>Class文件格式放弃了编译后代码的操作数长度对齐，故而超过一个字节的数据时需要从字节中重建出具体数据的结构（虽然损失性能但是编译后代码精干，传输效率高）</li>
</ul>
</li>
<li>字节码与数据类型<ul>
<li>指令集中大多数指令包含其操作所对应的数据类型，如：<code>iload--int</code>，<code>fload--float</code></li>
<li>有限的指令集长度使得其<strong>只针对有限的类型提供相关指令支持</strong>，必要时需将不支持的 类型转换为可被支持的类型（如，将byte, char和short和boolean扩展为相应的int类型数据）</li>
<li>加载和存储指令：用于将数据在栈帧中的局部变量表和操作数栈之间来回传输<ul>
<li>将一个局部变量加载到操作栈中：load</li>
<li>将一个数值从操作数栈存储到局部变量表：store</li>
<li>将一个常量加载到操作数栈：push</li>
<li>扩充局部变量表的访问索引的指令：wide</li>
</ul>
</li>
<li>运算指令：用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶；大体上分为： 对整型数据(char, short, int, boolean)/ 浮点型 数据进行运算的指令<ul>
<li>加add；减sub；乘mul；除div；</li>
<li>求余div；取反neg；位移shl；</li>
<li>按位或or；按位与and；按位异或xor；</li>
<li>局部变量自增：iinc；</li>
<li>比较指令：<code>dcmpg, dcmpl, fcmpg, fcmpl, lcmp</code></li>
<li>(只有除法和求余才会出现ArithmeticException；浮点数转换为整数时直接导致数字被截断)</li>
</ul>
</li>
<li>类型转换指令：不同数值类型进行相互转换，直接支持宽化类型转换（安全转换）；窄化类型转换必须使用显式转换指令（可能会导致转换结果产生不同的正负号、不同数量级）<ul>
<li>数据类型窄化转换会导致上限溢出、下限溢出和精度丢失等，但是JVM不会抛出运行时异常</li>
</ul>
</li>
<li>对象创建与访问指令：<ul>
<li>创建类实例的指令：new</li>
<li>创建数组的 指令：newarray, anewarray, multianewarray</li>
<li>访问类字段和实例字段的指令：getfield, putfield, getstatic, putstatic</li>
<li>将一个数组元素加载到操作数栈的指令：(x)load</li>
<li>将一个数组元素的值存储到数组元素中的指令:  (x)store</li>
<li>取数组长度的指令： arraylength</li>
<li>检查类实例类型的指令： instanceof,  checkcast</li>
</ul>
</li>
<li>操作数栈管理指令：如同操作一个普通数据结构中的堆栈一样，如出栈、压栈和互换栈顶的两个元素</li>
<li>控制转移指令：条件分支(if)、复合条件分支(tableswitch)、无条件分支(goto, jsr)</li>
<li>方法调用和返回指令：<ul>
<li>invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派（虚方法分<br>派），这也是Java语言中最常见的方法分派方式。</li>
<li>invokeinterface指令用于调用接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。</li>
<li>invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法。</li>
<li>invokestatic指令用于调用类方法（static方法）</li>
<li>invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方<br>法，前面4条调用指令的分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li>
<li>方法返回指令根据返回值的类型区分，有：<code>ireturn, lreturn, freturn, dreturn和areturn</code></li>
</ul>
</li>
<li>异常处理指令：显式抛出异常athrow指令；并规定了许多运行时异常会在JVM检测到异常状况时自动抛出；处理异常（catch语句）用异常表来完成</li>
<li>同步指令：JVM支持方法级同步和方法内部一段指令序列的同步，两种都是管程<ul>
<li>方法级同步是隐式的，通过<code>ACC_SYNCHRONIZED</code>访问标志得知是否为同步方法，如果设置要求成功持有管程才能执行</li>
<li>指令集序列由synchronized语句块表示，JVM提供指令<code>monitorenter和monitorexit</code>来支持</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="公有设计和私有实现"><a href="#公有设计和私有实现" class="headerlink" title="公有设计和私有实现"></a>公有设计和私有实现</h4><p>在满足公有虚拟机设计规范的基础上，允许对具体实现做出修改和优化；这种伸缩性让JVM可以获得更高性能、更低内存消耗或更好可移植性。</p>
<h4 id="Class文件结构的发展"><a href="#Class文件结构的发展" class="headerlink" title="Class文件结构的发展"></a>Class文件结构的发展</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/21/java/jvm/JVM内存分配与回收理论实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="znewcradle">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Znewradle's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/21/java/jvm/JVM内存分配与回收理论实践/" itemprop="url">垃圾收集与内存分配策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-21T10:45:42+08:00">
                2019-04-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/04/21/java/jvm/JVM内存分配与回收理论实践/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2019/04/21/java/jvm/JVM内存分配与回收理论实践/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JVM内存分配与回收理论实践"><a href="#JVM内存分配与回收理论实践" class="headerlink" title="JVM内存分配与回收理论实践"></a>JVM内存分配与回收理论实践</h2><h3 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>2-3章：JVM内存分配与回收理论；4-5章实践</p>
<h4 id="JDK命令行工具"><a href="#JDK命令行工具" class="headerlink" title="JDK命令行工具"></a>JDK命令行工具</h4><blockquote>
<p> 在bin目录下有诸多JVM监视和故障处理工具</p>
</blockquote>
<ol>
<li>jps：虚拟机进程状况工具（JVM Process Status Tool）<ul>
<li>显示JVM执行主类Main Class + 进程本地JVM唯一ID，即LVMID（与OS的进程ID一直），命令格式：<code>jps [options] [hostid]</code>，选项：-q只输出LVMID；-m显示启动时传给Main Class的main()的参数；-l输出主类全名，如果是jar包则输出jar包路径；-v输出VM进程启动时JVM参数</li>
</ul>
</li>
<li>jstat：虚拟机统计信息监视工具（JVM Statistics Monitoring Tool）<ul>
<li>监视虚拟机运行状态信息（类装载，内存、垃圾收集、JIT编译等），命令：<code>jstat [option vmid[interval[s|ms][count]]]</code>；如果是本地虚拟机进程则VMID与LVMID一致，若是远程VM进程，则VMID格式为：<code>[protocal:][//]lvmid[@hostname[:port]/servername]</code></li>
<li>通过interval和count指定查询间隔和次数，option代表用户希望查询的虚拟机信息，分为3类：类装载、垃圾收集、运行期编译状况；常用的有：<code>-class,  -gc, -gcutil,  -gcnew, -gcold</code></li>
<li>其中，<code>jstat -gcutil vmid</code>的显示结果中，<ul>
<li>S0， S1两个Survivor区；E是新生代Eden区；O老年代为Old；P表示永久区Permanent；</li>
<li>YGC程序运行以来Minor GC的次数；FGC表示程序运行以来Full GC的次数；</li>
<li>FGCT表示Full GC总耗时；所有GC总耗时为GCT</li>
</ul>
</li>
</ul>
</li>
<li>jinfo：Java配置信息工具—Configuration Info For Java<ul>
<li>实时查看和调整虚拟机各项参数，通过jps -v可以看到VM启动时显式指定的参数列表；查看默认值，则需要<code>jinfo -flag</code></li>
<li>命令格式：<code>jinfo [option] pid</code></li>
</ul>
</li>
<li>jmap：Java内存映像工具<ul>
<li>用于生成堆转储快照（heapdump或dump文件），命令格式：<code>jmap [option] vmid</code></li>
<li>option选项：-dump:[live, ]生成heapdump；-heap显示java堆详细信息；-histo显示堆中对象的统计信息；-permstat显示永久内存状态；-F强制生成dump快照</li>
</ul>
</li>
<li>jhat：虚拟机堆转储快照分析工具<ul>
<li>搭配jmap，分析jmap生成的堆转储快照，但是一般用VisualVM使用</li>
</ul>
</li>
<li>jstack：Java堆栈跟踪工具<ul>
<li><code>jstack [option] vmid</code>生成VM当前时刻的线程快照，定位线程问题，-F强制输出线程堆栈；-l显示关于锁的附加信息；-m调用本地方法可以显示C/C++堆栈</li>
</ul>
</li>
<li>HSDIS：JIT生成代码反汇编<ul>
<li>HotSpot虚拟机JIT编译代码的反汇编插件，包含在HotSpot虚拟机的源码中</li>
</ul>
</li>
</ol>
<h4 id="JDK的可视化工具"><a href="#JDK的可视化工具" class="headerlink" title="JDK的可视化工具"></a>JDK的可视化工具</h4><ol>
<li>JConsole（Java Monitoring and Management Console）Java监视与管理控制台</li>
<li>VisualVM：All-in-one Java Troubleshooting Tool多合一故障处理工具</li>
</ol>
<h3 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h3><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><ol>
<li>由Windows虚拟内存导致的长时间停顿<ul>
<li>程序最小化时，它的工作内存被自动交换到磁盘的页面文件之中</li>
<li>用：<code>-Dsun.awt.keepWorkingSetOnMinimize=true</code></li>
</ul>
</li>
<li>不恰当数据结构导致内存占用过大<ul>
<li>用HashMap存储大量数据，空间效率太低；新生代对象使用复制算法暂停时间明显过长</li>
<li>可以考虑将Survivor空间去掉，用<code>-XX: SurvivorRatio=65536 -XX: MaxTenuringThreshold=0或者-XX: +AlwaysTenure</code>，让新生代中存活的对象在第一Minor GC后立即进入老年代，等到Major GC时再清理（治标）</li>
</ul>
</li>
<li>服务器JVM进程崩溃<ul>
<li>远端连接异常，使用异步方式调用web服务，两边服务速度完全不对等，时间越长累积越多调用，导致在等待的线程和Socket连接越来越多，导致超过JVM的承受能力后崩溃</li>
<li>将异步调用改为生产者/消费者模式的消息队列</li>
</ul>
</li>
<li>外部命令导致系统缓慢<ul>
<li>用本地方法执行shell脚本，在JVM中非常消耗资源，因为在频繁调用时会创建进程：首先克隆一个和当前VM一样环境变量的进程；再用这个新进程来执行外部命令；最后推出这个进程</li>
<li>改用Java的API，去掉Shell脚本执行</li>
</ul>
</li>
<li>堆外内存导致的溢出错误<ul>
<li>Direct Memory内存不算入堆，只能使用分配给JVM的内存减去堆内存后的堆外内存；虚拟机对Direct Memory的回收需要等待Full GC</li>
<li>通过<code>-XX: MaxDirectMemorySize</code>调整大小，内存不足时抛出<code>OutOfMemoryError</code>；线程堆栈不足是通过-Xss调整大小，抛出<code>StackOverflowError</code>或者<code>OutOfMemoryError</code>；Socket缓存区内存可以抛出<code>IOException: Too many open files</code></li>
</ul>
</li>
<li>集群间同步导致的内存溢出<ul>
<li>集群间通信数据过多，并且会缓存发出的消息，积累重发数据，导致了内存溢出</li>
</ul>
</li>
<li>高性能硬件上的程序部署策略<ul>
<li>部署方式<ul>
<li>使用64未JDK：但性能普遍低于32位</li>
<li>若干个32位虚拟机建立逻辑集群利用硬件资源</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="实战：Eclipse运行速度调优"><a href="#实战：Eclipse运行速度调优" class="headerlink" title="实战：Eclipse运行速度调优"></a>实战：Eclipse运行速度调优</h4><ol>
<li>调优前的程序运行状态</li>
<li>升级JDK1.6的性能变化以及兼容问题</li>
<li>编译时间和类加载时间优化</li>
<li>调整内存设置控制案例收集频率</li>
<li>选择收集器降低延迟</li>
</ol>
<blockquote>
<p><strong>JDK8将PermSize永生代（JDK7及以前）用MetaSpace元空间来代替</strong></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">znewcradle</p>
              <p class="site-description motion-element" itemprop="description">This is a website to show my blogs</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/znewcradle" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-globe"></i>GitHub</a>
                </span>
              
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">znewcradle</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"your-duoshuo-shortname"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  


















  





  

  

  
  

  

  

  

</body>
</html>
